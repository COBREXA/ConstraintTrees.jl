<!doctype html>
<html>
<head>
<title>ConstraintTree browser</title>
<script type="module">
  import {h, Component, render, createContext } from 'https://esm.sh/preact';
  import { useContext, useState, useMemo, useReducer } from 'https://esm.sh/preact/hooks';
  import htm from 'https://esm.sh/htm';
  const html = htm.bind(h);

  const GlobalState = createContext(null);

  function VarRef(props) {
    const {type, v} = props;
    const { visibleVarOrder, nVisibleVars, constantVarDisplayed } = useContext(GlobalState);
    const cwd = constantVarDisplayed ? 1 : 0;
    const r = (visibleVarOrder.get(v) - cwd) / (nVisibleVars - cwd);

    const color =
      v == 0 ? (
        type == 'tree'
        ? "hsl(0, 0%, 33%)"
        : "hsl(0, 0%, 55%)"
      ) : (
        type == 'tree'
        ? `hsl(${360*r}, 33%, 33%)`
        : `hsl(${360*r}, 80%, 66%)`
      );

    const cls = type == 'tree' ? "var treevar" : type == 'sub' ? "var qvar" : "var";

    return html`<span class="${cls}" style="background-color: ${color};">${props.children}</span>`;
  }

  function VisibleVariable(props) {
    const {visibleVars, activeVars, triggerActiveVar} = useContext(GlobalState);
    const {type, v, vars} = props;
    if(!vars.has(v)) return html`<td key=${v}></td>`;
    if(type=='tree')
      return html`<td onClick=${() => triggerActiveVar(v)}
                      class="${activeVars.has(v) ? "triggered" : ""} trigger">
        <${VarRef} type=${type} v=${v}></>
      </td>`;
    if(type=='lin')
      return html`<td onClick=${() => triggerActiveVar(v)}
                      class="${activeVars.has(v) ? "triggered" : ""} trigger">
        <${VarRef} type=${type} v=${v}>${vars.get(v)}</>
      </td>`;
    if(type == 'quad') {
      var sub=[];
      vars.get(v).forEach((v,k) => {
        if(visibleVars.has(k)) sub.push(html`<${VarRef} type="sub" v=${k}>${v}</>`);
      });
      return html`<td onClick=${() => triggerActiveVar(v)}
                      class="${activeVars.has(v) ? "triggered" : ""} trigger">
        <${VarRef} type=${type} v=${v}>${sub}</>
      </td>`;
    }
    return html`<td>?</td>`;
  }

  function Variables(props) {
    const {sortedVisibleVars} = useContext(GlobalState);
    const {type, vars} = props;

    return sortedVisibleVars.map(v =>
      html`<${VisibleVariable} key=${v} type=${type} v=${v} vars=${vars} />`
    );
  }

  function Bound(props) {
    const {type, bound} = props;
    const sym = type == 'tree' ? "ðŸ—€" : type == 'lin' ? "âŸ‹" : type == 'quad' ? "â—‹" : "?";
    if(bound === null) return sym;
    else if(typeof(bound) === 'number') return `${sym} = ${bound}`;
    else if(typeof(bound) === 'object' && bound.length == 2) return `${bound[0] == null ? "-âˆž" : bound[0]} â‰¤ ${sym} â‰¤ ${bound[1] == null ? "âˆž" : bound[1]}`;
    else return `?${sym}?`;
  }

  function BrowserRow(props) {
    const {idx, item} = props;
    const {tree, activeRows, triggerActiveRow} = useContext(GlobalState);

    return html`<tr key=${idx}>
      <td onClick=${() => triggerActiveRow(idx)} class="${activeRows.has(idx) ? "triggered" : ""} trigger dirname">
        ${[...Array(item.lvl)].map(i => html`<span key=${i} class="dir-padding">Â·</span>`)}
        ${item.name}
      </td>
      <td>
        <${Bound} type=${item.type} bound=${'bound' in item ? item.bound : null} />
      </td>
      <${Variables} type=${item.type} vars=${item.vars} />
    </tr>`;
  }

  function Browser(props) {
    const {tree, visibleRows} = useContext(GlobalState);
    function tableRow(item, index) {
      if(visibleRows.has(index))
        return html`<${BrowserRow} idx=${index} item=${item} />`;
      else
        return html``;
    }
    return html`<table>${tree.data.rows.map(tableRow)}</table>`;
  }

  function processTree(json) {
    var max_var = 0;
    var items = [];

    function lin_vals(arr, pset) {
      var res=new Map();
      arr.map(x => {
        res.set(x[0], x[1]);
        pset.add(x[0]);
      });
      return res;
    }

    function quad_vals(arr, pset) {
      var res=new Map();
      arr.map(x => {
        const v1=x[0][0], v2=x[0][1], w=x[1];
        if(res.has(v1)) res.get(v1).set(v2, w);
        else res.set(v1, new Map([[v2,w]]));
        if(res.has(v2)) res.get(v2).set(v1, w);
        else res.set(v2, new Map([[v1,w]]));
        pset.add(v1);
        pset.add(v2);
      });
      return res;
    }

    function walkTree(js, lvl, pid, id, name, pset, pidx) {
      if('tree' in js) {
        var vs = new Set();
        const idx = items.length;
        items.push({type: "tree",
          lvl:lvl, pid: pid, id: id, name: name, pidx: pidx,
          vars: vs
        });
        Object.keys(js.tree).sort().map(
          cid => walkTree(js.tree[cid], lvl+1, id, id+'/'+cid, cid, vs, idx)
        );
        for(var v of vs) pset.add(v);
      } else {
        if('lin' in js.value)
          items.push({
            type: "lin",
            lvl:lvl, pid: pid, id: id, name: name, pidx: pidx,
            bound: js.bound,
            value: js.value.lin,
            vars: lin_vals(js.value.lin, pset)
          });
        else
          items.push({
            type: "quad",
            lvl:lvl, pid: pid, id: id, name: name, pidx: pidx,
            bound: js.bound,
            value: js.value.quad,
            vars: quad_vals(js.value.quad, pset)
          });
      }
    }

    var s = new Set();
    walkTree(json, 0, '', '', '/', s, -1);

    return {rows: items, maxvar: Math.max(...s)};
  }

  function collectVisibleVars(tree, activeRows, activeVars) {
    var visibleVars = new Set();
    if(!tree) return visibleVars;
    activeVars.forEach(v => visibleVars.add(v));
    tree.data.rows.forEach((t, idx) => {
      if(activeRows.has(idx) && (t.type == 'lin' || t.type == 'quad')) {
        t.vars.forEach((v,k) => visibleVars.add(k));
      }
    });
    return visibleVars;
  }

  function collectVisibleRows(tree, activeRows, activeVars) {
    /* TODO all parents of anything that is shown? */
    var visibleRows = new Set([0]);
    function add(i) {
      while(true) {
        if(visibleRows.has(i)) break;
        visibleRows.add(i);
        i = tree.data.rows[i].pidx;
      }
    }
    if(!tree) return visibleRows;
    activeRows.forEach(add);
    tree.data.rows.forEach((t, i) => {
      if(activeRows.has(t.pidx)) add(i);
      t.vars.forEach((v,k) => {
        if(activeVars.has(k)) add(i);
      });
    });
    return visibleRows;
  }

  function App(props) {
    const [tree, setTree] = useState(null);
    const [activeRows, triggerActiveRow] = useReducer((state, id) => {
      var ns = new Set(Array.from(state));
      if(ns.has(id))
        ns.delete(id);
      else
        ns.add(id);
      return ns;
    }, new Set());
    const [activeVars, triggerActiveVar] = useReducer((state, v) => {
      var ns = new Set(Array.from(state));
      if(ns.has(v))
        ns.delete(v);
      else
        ns.add(v);
      return ns;
    }, new Set());

    const visibleRows = useMemo(
      () => {
        return collectVisibleRows(tree, activeRows, activeVars);
      },
      [tree, activeRows, activeVars]
    );
    const visibleVars = useMemo(
      () => {
        return collectVisibleVars(tree, activeRows, activeVars);
      },
      [tree, activeRows, activeVars]
    );
    const constantVarDisplayed = useMemo(
      () => visibleVars.has(0),
      [visibleVars]
    );
    const sortedVisibleVars = useMemo(
      () => Array.from(visibleVars).sort((a,b) => a-b),
      [visibleVars]
    );
    const nVisibleVars = useMemo(
      () => sortedVisibleVars.length,
      [sortedVisibleVars]
    );
    const visibleVarOrder = useMemo(
      () => {
        var m = new Map();
        sortedVisibleVars.forEach((v,k) => m.set(v, k));
        return m;
      },
      [sortedVisibleVars]
    );

    const loadState = function(event) {
      var input = event.target;
      var reader = new FileReader();
      reader.onload = function() {
        setTree({
          filename: input.files[0].name,
          data: processTree(JSON.parse(reader.result))
        });
      };
      reader.readAsText(input.files[0]);
    }

    const contextVal = {
      tree: tree, setTree: setTree,
      activeRows: activeRows, triggerActiveRow: triggerActiveRow,
      activeVars: activeVars, triggerActiveVar: triggerActiveVar,
      visibleRows: visibleRows, visibleVars: visibleVars,
      constantVarDisplayed: constantVarDisplayed,
      sortedVisibleVars: sortedVisibleVars, nVisibleVars: nVisibleVars,
      visibleVarOrder: visibleVarOrder
    };

    if(tree)
      return html`<${GlobalState.Provider} value=${contextVal}><h1>ConstraintTree ${tree.filename}</h1><${Browser}/></>`;
    else
      return html`<>
        <h1>ConstraintTree browser</h1>
        <p>Open a constraint tree as exported from <a href="https://github.com/COBREXA/ConstraintTrees.jl">ConstraintTrees.jl</a> package below:</p>
        <div><input type="file" onChange=${loadState}></div>
        <pre># reference export code:
import ConstraintTrees, JSON
open("<strong>YOUR FILE NAME</strong>.json", "w") do f
  write(f, JSON.json(ConstraintTrees.dictify(<strong>YOUR TREE VARIABLE</strong>)))
end</pre>
      </>`;
  }

  const app_elem = document.getElementById("ctb-app");
  app_elem.innerHTML = "";
  render(html`<${App}/>`, app_elem);
</script>
<style type="text/css">
body {
  background: #222;
  color: #ddd;
  font-family: 'sans', 'sans-serif';
}

a {
  color: inherit;
}

a:visited {
  color: inherit;
}

a:hover {
  color: #fff;
}

strong {
  color: #fc4;
}

table {
  border-collapse: collapse;
}

td {
  padding: 0.5em;
  white-space: nowrap;
  border-left: 1px solid #333;
}

td.dirname {
  min-width: 5em;
}

span.dir-padding {
  margin-right: 1em;
}

td.trigger {
  cursor: pointer;
}

td.trigger:hover {
  background-color: #666;
}

tr:nth-child(odd) {
  background-color: #2a2a2a;
}

td.triggered {
  background-color: #444;
}

span.var {
  min-width: 1em;
  min-height: 1em;
  display: block;
  padding: 0.5em;
  margin: 0.25em;
  border-radius: 0.5em;
  font-size: 80%;
  font-weight: bold;
  color: black;
  text-align: center;
}

span.treevar {
}

span.qvar {
  border: 0.25em solid black;
}

</style>
</head>
<body><div id="ctb-app">This needs javascript.</div></body>
</html>
