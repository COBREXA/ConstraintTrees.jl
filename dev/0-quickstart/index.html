<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick start ¬∑ ConstraintTrees.jl</title><meta name="title" content="Quick start ¬∑ ConstraintTrees.jl"/><meta property="og:title" content="Quick start ¬∑ ConstraintTrees.jl"/><meta property="twitter:title" content="Quick start ¬∑ ConstraintTrees.jl"/><meta name="description" content="Documentation for ConstraintTrees.jl."/><meta property="og:description" content="Documentation for ConstraintTrees.jl."/><meta property="twitter:description" content="Documentation for ConstraintTrees.jl."/><meta property="og:url" content="https://cobrexa.github.io/ConstraintTrees.jl/stable/0-quickstart/"/><meta property="twitter:url" content="https://cobrexa.github.io/ConstraintTrees.jl/stable/0-quickstart/"/><link rel="canonical" href="https://cobrexa.github.io/ConstraintTrees.jl/stable/0-quickstart/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConstraintTrees.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li class="is-active"><a class="tocitem" href>Quick start</a><ul class="internal"><li><a class="tocitem" href="#The-problem:-Field-area-allocation"><span>The problem: Field area allocation</span></a></li><li><a class="tocitem" href="#Field-area-allocation-with-ConstraintTrees.jl"><span>Field area allocation with ConstraintTrees.jl</span></a></li><li><a class="tocitem" href="#Solving-the-system-with-JuMP"><span>Solving the system with JuMP</span></a></li><li><a class="tocitem" href="#Browsing-the-result"><span>Browsing the result</span></a></li><li><a class="tocitem" href="#Increasing-the-complexity"><span>Increasing the complexity</span></a></li><li><a class="tocitem" href="#Combining-constraint-systems:-Let&#39;s-have-a-factory!"><span>Combining constraint systems: Let&#39;s have a factory!</span></a></li></ul></li><li><a class="tocitem" href="../1-metabolic-modeling/">Example: Metabolic modeling</a></li><li><a class="tocitem" href="../2-quadratic-optimization/">Example: Quadratic optimization</a></li><li><a class="tocitem" href="../3-mixed-integer-optimization/">Example: Mixed integer optimization (MILP)</a></li><li><a class="tocitem" href="../4-functional-tree-processing/">Example: Processing the trees functionally</a></li><li><a class="tocitem" href="../5-jump-integration/">Better integration with JuMP</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick start</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/COBREXA/ConstraintTrees.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/master/docs/src/0-quickstart.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-start"><a class="docs-heading-anchor" href="#Quick-start">Quick start</a><a id="Quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start" title="Permalink"></a></h1><p>The primary purpose of ConstraintTrees.jl is to make the representation of constraint systems neat, and thus make their manipulation easy and high-level. In short, the package abstracts the users from keeping track of variable and constraint indexes in matrix form, and gives a nice data structure that describes the system, while keeping all variable allocation and constraint organization completely implicit.</p><p>Here we demonstrate the absolutely basic concepts on the &quot;field allocation&quot; problem.</p><h2 id="The-problem:-Field-area-allocation"><a class="docs-heading-anchor" href="#The-problem:-Field-area-allocation">The problem: Field area allocation</a><a id="The-problem:-Field-area-allocation-1"></a><a class="docs-heading-anchor-permalink" href="#The-problem:-Field-area-allocation" title="Permalink"></a></h2><p>Suppose we have 100 square kilometers of field, 500 kilos of fertilizer and 300 kilos of insecticide. We also have a practically infinite supply of wheat and barley seeds. If we decide to sow barley, we can make 550ü™ô per square kilometer of harvest; if we decide to go with wheat instead, we can make 350ü™ô. Unfortunately each square kilometer of wheat requires 6 kilos of fertilizer, and 1 kilo of insecticide, whereas each square kilometer of barley requires 2 kilos of fertilizer and 4 kilos of insecticide, because insects love barley.</p><p>How much of our fields should we allocate to wheat and barley to maximize our profit?</p><h2 id="Field-area-allocation-with-ConstraintTrees.jl"><a class="docs-heading-anchor" href="#Field-area-allocation-with-ConstraintTrees.jl">Field area allocation with ConstraintTrees.jl</a><a id="Field-area-allocation-with-ConstraintTrees.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Field-area-allocation-with-ConstraintTrees.jl" title="Permalink"></a></h2><p>Let&#39;s import the package and start constructing the problem:</p><pre><code class="language-julia hljs">import ConstraintTrees as C</code></pre><p>Let&#39;s name our system <code>s</code>. We first need a few <a href="../reference/#ConstraintTrees.variables-Tuple{}"><code>variables:</code></a></p><pre><code class="language-julia hljs">s = C.variables(keys = [:wheat, :barley])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 2 elements:
  :barley =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :wheat  =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))</code></pre><p>With ConstraintTrees.jl, we can (and want to!) label everything very nicely ‚Äì the constraint trees are essentially directory structures, so one can prefix everything with symbols to put it into nice directories, e.g. as such:</p><pre><code class="language-julia hljs">:area^s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 1 element:
  :area =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)</code></pre><p>To be absolutely realistic, we also want to make sure that all areas are non-negative. To demonstrate how to do that nicely from the start, we rather re-do the constraints with an appropriate <a href="../reference/#ConstraintTrees.Between">interval bound</a>:</p><pre><code class="language-julia hljs">s = :area^C.variables(keys = [:wheat, :barley], bounds = C.Between(0, Inf))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 1 element:
  :area =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)</code></pre><p>Constraint trees can be browsed using dot notation, or just like dictionaries:</p><pre><code class="language-julia hljs">s.area</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 2 elements:
  :barley =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#), ConstraintTrees.Between(0.0, Inf))
  :wheat  =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#), ConstraintTrees.Between(0.0, Inf))</code></pre><pre><code class="language-julia hljs">s[:area].barley</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Constraint(ConstraintTrees.LinearValue([2], [1.0]), ConstraintTrees.Between(0.0, Inf))</code></pre><p>(For convenience in some cases, string indexes are also supported:)</p><pre><code class="language-julia hljs">s[&quot;area&quot;][&quot;barley&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Constraint(ConstraintTrees.LinearValue([2], [1.0]), ConstraintTrees.Between(0.0, Inf))</code></pre><p>Now let&#39;s start rewriting the problem into the constraint-tree-ish description. First, we only have 100 square kilometers of area:</p><pre><code class="language-julia hljs">total_area = s.area.wheat.value + s.area.barley.value

total_area_constraint = C.Constraint(total_area, (0, 100))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Constraint(ConstraintTrees.LinearValue([1, 2], [1.0, 1.0]), ConstraintTrees.Between(0.0, 100.0))</code></pre><p>We can add any kind of <a href="../reference/#ConstraintTrees.Constraint">constraint</a> into the existing constraint trees by &quot;merging&quot; multiple trees with operator <code>*</code>:</p><pre><code class="language-julia hljs">s *= :total_area^total_area_constraint</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 2 elements:
  :area       =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :total_area =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#), ConstraintTrees.Between(0.0, 100.0))</code></pre><p>Now let&#39;s add constraints for resources. We can create whole <a href="../reference/#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> structures like dictionaries in place, as follows:</p><pre><code class="language-julia hljs">s *=
    :resources^C.ConstraintTree(
        :fertilizer =&gt;
            C.Constraint(s.area.wheat.value * 6 + s.area.barley.value * 2, (0, 500)),
        :insecticide =&gt;
            C.Constraint(s.area.wheat.value * 1 + s.area.barley.value * 4, (0, 300)),
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 3 elements:
  :area       =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :resources  =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :total_area =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#), ConstraintTrees.Between(0.0, 100.0))</code></pre><p>We can also represent the expected profit as a constraint (although we do not need to actually put a constraint bound there):</p><pre><code class="language-julia hljs">s *= :profit^C.Constraint(s.area.wheat.value * 350 + s.area.barley.value * 550)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 4 elements:
  :area       =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :profit     =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :resources  =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :total_area =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#), ConstraintTrees.Between(0.0, 100.0))</code></pre><h2 id="Solving-the-system-with-JuMP"><a class="docs-heading-anchor" href="#Solving-the-system-with-JuMP">Solving the system with JuMP</a><a id="Solving-the-system-with-JuMP-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-system-with-JuMP" title="Permalink"></a></h2><p>We can now take the structure of the constraint tree, translate it to any suitable linear optimizer interface, and have it solved. For popular reasons we choose <a href="https://jump.dev/">JuMP</a> with <a href="https://www.gnu.org/software/glpk/">GLPK</a> ‚Äì the code is left uncommented here as-is; see the other examples for a slightly more detailed explanation:</p><pre><code class="language-julia hljs">import JuMP
function optimized_vars(cs::C.ConstraintTree, objective::C.LinearValue, optimizer)
    model = JuMP.Model(optimizer)
    JuMP.@variable(model, x[1:C.var_count(cs)])
    JuMP.@objective(model, JuMP.MAX_SENSE, C.substitute(objective, x))
    C.traverse(cs) do c
        b = c.bound
        if b isa C.EqualTo
            JuMP.@constraint(model, C.substitute(c.value, x) == b.equal_to)
        elseif b isa C.Between
            val = C.substitute(c.value, x)
            isinf(b.lower) || JuMP.@constraint(model, val &gt;= b.lower)
            isinf(b.upper) || JuMP.@constraint(model, val &lt;= b.upper)
        end
    end
    JuMP.optimize!(model)
    JuMP.value.(model[:x])
end

import GLPK
optimal_variable_assignment = optimized_vars(s, s.profit.value, GLPK.Optimizer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 33.333333333333336
 66.66666666666667</code></pre><p>This gives us the optimized variable values! If we cared to remember what they stand for, we might already know how much barley to sow. On the other hand, the main point of ConstraintTree.jl is that one should not be forced to remember things like variable ordering and indexes, or be forced to manually calculate how much money we actually make or how much fertilizer is going to be left ‚Äì instead, we can simply <a href="../reference/#ConstraintTrees.substitute_values">feed the variable values back to the constraint tree</a>, and get a really good overview of all values in our constrained system:</p><pre><code class="language-julia hljs">optimal_s = C.substitute_values(s, optimal_variable_assignment)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 4 elements:
  :area       =&gt; ConstraintTrees.Tree{Float64}(#= 2 elements =#)
  :profit     =&gt; 48333.3
  :resources  =&gt; ConstraintTrees.Tree{Float64}(#= 2 elements =#)
  :total_area =&gt; 100.0</code></pre><h2 id="Browsing-the-result"><a class="docs-heading-anchor" href="#Browsing-the-result">Browsing the result</a><a id="Browsing-the-result-1"></a><a class="docs-heading-anchor-permalink" href="#Browsing-the-result" title="Permalink"></a></h2><p><code>optimal_s</code> is now like the original constraint tree, just the contents are &quot;plain old values&quot; instead of the constraints as above. Thus we can easily see our profit:</p><pre><code class="language-julia hljs">optimal_s.profit</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48333.33333333334</code></pre><p>The occupied area for each crop:</p><pre><code class="language-julia hljs">optimal_s.area</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 2 elements:
  :barley =&gt; 66.6667
  :wheat  =&gt; 33.3333</code></pre><p>The consumed resources:</p><pre><code class="language-julia hljs">optimal_s.resources</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 2 elements:
  :fertilizer  =&gt; 333.333
  :insecticide =&gt; 300.0</code></pre><h2 id="Increasing-the-complexity"><a class="docs-heading-anchor" href="#Increasing-the-complexity">Increasing the complexity</a><a id="Increasing-the-complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Increasing-the-complexity" title="Permalink"></a></h2><p>A crucial property of constraint trees is that the users do not need to care about what kind of value they are manipulating ‚Äì no matter if something is a variable or a derived value, the code that works with it is the same. For example, we can use the actual prices for our resources (30ü™ô and 110ü™ô for a kilo of fertilizer and insecticide, respectively) to make a corrected profit:</p><pre><code class="language-julia hljs">s *=
    :actual_profit^C.Constraint(
        s.profit.value - 30 * s.resources.fertilizer.value -
        110 * s.resources.insecticide.value,
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 5 elements:
  :actual_profit =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :area          =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :profit        =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :resources     =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :total_area    =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#), ConstraintTrees.Between(0.0, 100.0))</code></pre><p>Is the result going to change if we optimize for the corrected profit?</p><pre><code class="language-julia hljs">realistically_optimal_s =
    C.substitute_values(s, optimized_vars(s, s.actual_profit.value, GLPK.Optimizer))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 5 elements:
  :actual_profit =&gt; 5750.0
  :area          =&gt; ConstraintTrees.Tree{Float64}(#= 2 elements =#)
  :profit        =&gt; 40000.0
  :resources     =&gt; ConstraintTrees.Tree{Float64}(#= 2 elements =#)
  :total_area    =&gt; 100.0</code></pre><pre><code class="language-julia hljs">realistically_optimal_s.area</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 2 elements:
  :barley =&gt; 25.0
  :wheat  =&gt; 75.0</code></pre><h2 id="Combining-constraint-systems:-Let&#39;s-have-a-factory!"><a class="docs-heading-anchor" href="#Combining-constraint-systems:-Let&#39;s-have-a-factory!">Combining constraint systems: Let&#39;s have a factory!</a><a id="Combining-constraint-systems:-Let&#39;s-have-a-factory!-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-constraint-systems:-Let&#39;s-have-a-factory!" title="Permalink"></a></h2><p>The second crucial property of constraint trees is the ability to easily combine different constraint systems into one. Let&#39;s pretend we also somehow obtained a food factory that produces malty sweet bread and wheaty weizen-style beer, with various extra consumptions of water and heat for each of the products. For simplicity, let&#39;s just create the corresponding constraint system (<code>f</code> as a factory) here:</p><pre><code class="language-julia hljs">f = :products^C.variables(keys = [:bread, :weizen], bounds = C.Between(0, Inf))
f *= :profit^C.Constraint(25 * f.products.weizen.value + 35 * f.products.bread.value)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 2 elements:
  :products =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :profit   =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))</code></pre><p>We can make the constraint systems more complex by adding additional variables. To make sure the variables do not &quot;conflict&quot;, one must use the <code>+</code> operator. While constraint systems combined with <code>*</code> always share variables, constraint systems combined with <code>+</code> are independent.</p><pre><code class="language-julia hljs">f += :materials^C.variables(keys = [:wheat, :barley], bounds = C.Between(0, Inf))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 3 elements:
  :materials =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :products  =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :profit    =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))</code></pre><p>How much resources are consumed by each product, with a limit on each:</p><pre><code class="language-julia hljs">f *=
    :resources^C.ConstraintTree(
        :heat =&gt; C.Constraint(
            5 * f.products.bread.value + 3 * f.products.weizen.value,
            (0, 1000),
        ),
        :water =&gt; C.Constraint(
            2 * f.products.bread.value + 10 * f.products.weizen.value,
            (0, 3000),
        ),
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 4 elements:
  :materials =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :products  =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :profit    =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :resources =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)</code></pre><p>How much raw materials are required for each product:</p><pre><code class="language-julia hljs">f *=
    :material_allocation^C.ConstraintTree(
        :wheat =&gt; C.Constraint(
            8 * f.products.bread.value + 2 * f.products.weizen.value -
            f.materials.wheat.value,
            0,
        ),
        :barley =&gt; C.Constraint(
            0.5 * f.products.bread.value + 10 * f.products.weizen.value -
            f.materials.barley.value,
            0,
        ),
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 5 elements:
  :material_allocation =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :materials           =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :products            =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)
  :profit              =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :resources           =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)</code></pre><p>Having the two systems at hand, we can connect the factory &quot;system&quot; <code>f</code> to the field &quot;system&quot; <code>s</code>, making a compound system <code>c</code> as such:</p><pre><code class="language-julia hljs">c = :factory^f + :fields^s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 2 elements:
  :factory =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 5 elements =#)
  :fields  =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 5 elements =#)</code></pre><div class="admonition is-warning"><header class="admonition-header">Operators for combining constraint trees</header><div class="admonition-body"><p>Always remember to use <code>+</code> instead of <code>*</code> when combining <em>independent</em> constraint systems. If we use <code>*</code>, the variables in both systems will become implicitly shared, which is rarely what one wants in the first place. Use <code>*</code> only if adding additional constraints to an existing system. As a rule of thumb, one can remember the boolean interpretation of <code>*</code> as &quot;and&quot; and of <code>+</code> as &quot;or&quot;.</p><p>On a side note, the operator <code>^</code> was chosen mainly to match the algebraic view of the tree combination, and nicely fit into Julia&#39;s operator priority structure.</p></div></div><p>To actually connect the systems (which now exist as completely independent parts of <code>s</code>), let&#39;s add a transport ‚Äì the barley and wheat produced on the fields is going to be the only barley and wheat consumed by the factory, thus their production and consumption must sum to net zero:</p><pre><code class="language-julia hljs">c *= :transport^C.zip(c.fields.area, c.factory.materials) do area, material
    C.Constraint(area.value - material.value, 0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 3 elements:
  :factory   =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 5 elements =#)
  :fields    =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 5 elements =#)
  :transport =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 2 elements =#)</code></pre><div class="admonition is-info"><header class="admonition-header">High-level constraint tree manipulation</header><div class="admonition-body"><p>There is also a <a href="../4-functional-tree-processing/">dedicated example</a> with many more useful functions like <a href="../reference/#ConstraintTrees.zip-Union{Tuple{T}, Tuple{Any, Any, Any}, Tuple{Any, Any, Any, Type{T}}} where T"><code>zip</code></a> above.</p></div></div><p>Finally, let&#39;s see how much money can we make from having the factory supported by our fields in total!</p><pre><code class="language-julia hljs">optimal_c =
    C.substitute_values(c, optimized_vars(c, c.factory.profit.value, GLPK.Optimizer))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 3 elements:
  :factory   =&gt; ConstraintTrees.Tree{Float64}(#= 5 elements =#)
  :fields    =&gt; ConstraintTrees.Tree{Float64}(#= 5 elements =#)
  :transport =&gt; ConstraintTrees.Tree{Float64}(#= 2 elements =#)</code></pre><p>How much field area did we allocate?</p><pre><code class="language-julia hljs">optimal_c.fields.area</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 2 elements:
  :barley =&gt; 25.0
  :wheat  =&gt; 75.0</code></pre><p>How much of each of the products does the factory make in the end?</p><pre><code class="language-julia hljs">optimal_c.factory.products</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 2 elements:
  :bread  =&gt; 8.86076
  :weizen =&gt; 2.05696</code></pre><p>How much extra resources is consumed by the factory?</p><pre><code class="language-julia hljs">optimal_c.factory.resources</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{Float64} with 2 elements:
  :heat  =&gt; 50.4747
  :water =&gt; 38.2911</code></pre><p>And what is the factory profit in the end?</p><pre><code class="language-julia hljs">optimal_c.factory.profit</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">361.5506329113926</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ README</a><a class="docs-footer-nextpage" href="../1-metabolic-modeling/">Example: Metabolic modeling ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 19 June 2024 09:31">Wednesday 19 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
