<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ConstraintTrees.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://cobrexa.github.io/ConstraintTrees.jl/stable/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConstraintTrees.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../metabolic-modeling/">Example: Metabolic modeling</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Values-(linear-combinations-of-variables)"><span>Values (linear combinations of variables)</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Constraint-trees"><span>Constraint trees</span></a></li><li><a class="tocitem" href="#Solution-trees"><span>Solution trees</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Values-(linear-combinations-of-variables)"><a class="docs-heading-anchor" href="#Values-(linear-combinations-of-variables)">Values (linear combinations of variables)</a><a id="Values-(linear-combinations-of-variables)-1"></a><a class="docs-heading-anchor-permalink" href="#Values-(linear-combinations-of-variables)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Value" href="#ConstraintTrees.Value"><code>ConstraintTrees.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Value</code></pre><p>A representation of a &quot;value&quot; in a linear constrained optimization problem. The value is a linear combination of several variables.</p><p>Values can be combined additively and multiplied by real-number constants.</p><p><strong>Fields</strong></p><ul><li><code>idxs::Vector{Int64}</code>: Indexes of the variables used by the value. The indexes are always sorted in increasing order.</li></ul><ul><li><code>weights::Vector{Float64}</code>: Coefficients of the variables as used by the value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/value.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Value-Tuple{SparseArrays.SparseVector{Float64}}" href="#ConstraintTrees.Value-Tuple{SparseArrays.SparseVector{Float64}}"><code>ConstraintTrees.Value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Value(
    x::SparseArrays.SparseVector{Float64}
) -&gt; ConstraintTrees.Value
</code></pre><p>Shortcut for making a <a href="#ConstraintTrees.Value"><code>Value</code></a> out of <code>SparseVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/value.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.value_product-Tuple{ConstraintTrees.Value, Any}" href="#ConstraintTrees.value_product-Tuple{ConstraintTrees.Value, Any}"><code>ConstraintTrees.value_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value_product(x::ConstraintTrees.Value, y) -&gt; Any
</code></pre><p>Shortcut for making a dot-product between a value and anything indexable by the value indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/value.jl#L67">source</a></section></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Bound" href="#ConstraintTrees.Bound"><code>ConstraintTrees.Bound</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Shortcut for possible bounds: either no bound is present (<code>nothing</code>), or a single number is interpreted as an exact equality bound, or a tuple of 2 values is interpreted as an interval bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Constraint" href="#ConstraintTrees.Constraint"><code>ConstraintTrees.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Constraint</code></pre><p>A representation of a single constraint that limits the <a href="#ConstraintTrees.Value"><code>Value</code></a> by a specific <a href="#ConstraintTrees.Bound"><code>Bound</code></a>.</p><p>Constraints may be multiplied by real-number constants.</p><p>Constraints without a bound (<code>nothing</code> in the <code>bound</code> field) are possible; these have no impact on the optimization problem but the associated <code>value</code> becomes easily accessible for inspection and building other constraints.</p><p><strong>Fields</strong></p><ul><li><p><code>value::ConstraintTrees.Value</code>: A <a href="#ConstraintTrees.Value"><code>Value</code></a> that describes what the constraint constraints.</p></li><li><p><code>bound::Union{Nothing, Float64, Tuple{Float64, Float64}}</code>: A bound that the value must satisfy.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.IntervalBound" href="#ConstraintTrees.IntervalBound"><code>ConstraintTrees.IntervalBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Tuple{Float64, Float64}</code></pre><p>Convenience shortcut for &quot;interval&quot; bound; consisting of lower and upper bound value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.value-Tuple{ConstraintTrees.Constraint}" href="#ConstraintTrees.value-Tuple{ConstraintTrees.Constraint}"><code>ConstraintTrees.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(
    x::ConstraintTrees.Constraint
) -&gt; ConstraintTrees.Value
</code></pre><p>Simple accessor for getting out the value from the constraint that can be used for broadcasting (as opposed to the dot-field access).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint.jl#L53">source</a></section></article><h2 id="Constraint-trees"><a class="docs-heading-anchor" href="#Constraint-trees">Constraint trees</a><a id="Constraint-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.ConstraintTreeElem" href="#ConstraintTrees.ConstraintTreeElem"><code>ConstraintTrees.ConstraintTreeElem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A shortcut for elements of the <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint_tree.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.ConstraintTree" href="#ConstraintTrees.ConstraintTree"><code>ConstraintTrees.ConstraintTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstraintTree</code></pre><p>A hierarchical tree of many constraints that together describe a constrained linear system. The tree may recursively contain other trees in a directory-like structure.</p><p>Members of the constraint tree are accessible via the record dot syntax as properties; e.g. a constraint labeled with <code>:abc</code> in a constraint tree <code>t</code> may be accessed as <code>t.abc</code> and as <code>t[:abc]</code>, and can be found while iterating through <code>elems(t)</code>.</p><p><strong>Constructing the constraint trees</strong></p><p>Use operator <code>^</code> to put a name on a <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a> to convert it into a single element <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>:</p><pre><code class="language-julia hljs">x = :my_constraint ^ Constraint(Value(...), 1.0)
dir = :my_constraint_dir ^ x

dir.my_constraint_dir.my_constraint.bound   # returns 1.0</code></pre><p>Use operator <code>*</code> to glue two constraint trees together while <em>sharing</em> the variable indexes specified by the contained <a href="#ConstraintTrees.Value"><code>Value</code></a>s.</p><pre><code class="language-julia hljs">my_constraints = :constraint1 ^ Constraint(...) * :constraint2 ^ Constraint(...)</code></pre><p>Use operator <code>+</code> to glue two constraint trees together <em>without sharing</em> of any variables. The operation will renumber the variables in the trees so that the sets of variable indexes used by either tree are completely disjunct, and then glue the trees together as with <code>*</code>:</p><pre><code class="language-julia hljs">two_independent_systems = my_system + other_system</code></pre><p>Because of the renumbering, you can not easily use constraints and values from the values <em>before</em> the addition in the constraint tree that is the result of the addition. There is no check against that; the resulting <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> will be valid, but will probably describe a different optimization problem than you intended.</p><p>As a rule of thumb, avoid necessary parentheses in expressions that work with the constraint trees: While <code>t1 * t2 + t3</code> might work just as intended, <code>t1 * (t2 + t3)</code> is almost certainly wrong because the variables in <code>t1</code> that are supposed to connect to variables in either of <code>t2</code> and <code>t3</code> will not connect properly because of renumbering of both <code>t2</code> and <code>t3</code>. If you need to construct a tree like that, do the addition first, and construct the <code>t1</code> after that, based on the result of the addition.</p><p><strong>Fields</strong></p><ul><li><code>elems::DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}}</code>: Sorted dictionary of elements of the constraint tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint_tree.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.allocate_variables-Tuple{}" href="#ConstraintTrees.allocate_variables-Tuple{}"><code>ConstraintTrees.allocate_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_variables(; keys, bounds)
</code></pre><p>Make a trivial constraint system that creates variables with indexes in range <code>1:length(keys)</code> named in order as given by <code>keys</code>.</p><p>Parameter <code>bounds</code> is either <code>nothing</code> for creating unconstrained variables, a single bound (of precise length 1) for creating all variables of the same constraint, or an iterable object of same length as <code>keys</code> with individual bounds for each variable in the same order as <code>keys</code>.</p><p>The individual bounds should be of type <a href="#ConstraintTrees.Bound"><code>Bound</code></a>. To pass a single interval bound for all variables, it is impossible to use a tuple (since its length is 2); in such case use <code>bound = Ref((minimum, maximum))</code>, which has the correct length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint_tree.jl#L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}" href="#ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}"><code>ConstraintTrees.elems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elems(
    x::ConstraintTrees.ConstraintTree
) -&gt; DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}}
</code></pre><p>Get the elements dictionary out of the <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>. This is useful for getting an iterable container for working with many constraints at once.</p><p>Also, because of the overload of <code>getproperty</code> for <code>ConstraintTree</code>, this serves as a simpler way to get the elements without an explicit use of <code>getfield</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint_tree.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.make_constraint_tree-Tuple" href="#ConstraintTrees.make_constraint_tree-Tuple"><code>ConstraintTrees.make_constraint_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_constraint_tree(x...) -&gt; ConstraintTrees.ConstraintTree
</code></pre><p>Create a properly typed <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> out of anything that can be used to construct the inner dictionary.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">make_constraint_tree(:a =&gt; some_constraint, :b =&gt; another_constraint)
make_constraint_tree(c for c=constraints if !isnothing(c.bound))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/constraint_tree.jl#L73">source</a></section></article><h2 id="Solution-trees"><a class="docs-heading-anchor" href="#Solution-trees">Solution trees</a><a id="Solution-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.SolutionTreeElem" href="#ConstraintTrees.SolutionTreeElem"><code>ConstraintTrees.SolutionTreeElem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A shortcut for type of contents in a <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/solution.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.SolutionTree" href="#ConstraintTrees.SolutionTree"><code>ConstraintTrees.SolutionTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SolutionTree</code></pre><p>A structure similar to <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>, but only holds the resolved values of each constraint. As with <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>, use record dot notation and <a href="#ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}"><code>elems</code></a> to browse the solution structure.</p><p>Use <a href="#ConstraintTrees.solution_tree-Tuple{ConstraintTrees.Constraint, AbstractVector{Float64}}"><code>solution_tree</code></a> to construct the <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a> out of a <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> and a vector of variable values.</p><p><strong>Fields</strong></p><ul><li><code>elems::DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/solution.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.elems-Tuple{ConstraintTrees.SolutionTree}" href="#ConstraintTrees.elems-Tuple{ConstraintTrees.SolutionTree}"><code>ConstraintTrees.elems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elems(
    x::ConstraintTrees.SolutionTree
) -&gt; DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}}
</code></pre><p>Get the elements dictionary out of the <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a>.</p><p>The use is similar as with the overload for <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/solution.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.solution_tree-Tuple{ConstraintTrees.Constraint, AbstractVector{Float64}}" href="#ConstraintTrees.solution_tree-Tuple{ConstraintTrees.Constraint, AbstractVector{Float64}}"><code>ConstraintTrees.solution_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution_tree(
    x::ConstraintTrees.Constraint,
    vars::AbstractVector{Float64}
) -&gt; Any
</code></pre><p>Convert a single constraint and a vector of variable assignments (typically representing a constrained problem solution) to the value of the constraint w.r.t. the given variable assignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/solution.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.solution_tree-Tuple{ConstraintTrees.ConstraintTree, AbstractVector{Float64}}" href="#ConstraintTrees.solution_tree-Tuple{ConstraintTrees.ConstraintTree, AbstractVector{Float64}}"><code>ConstraintTrees.solution_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution_tree(
    x::ConstraintTrees.ConstraintTree,
    vars::AbstractVector{Float64}
) -&gt; ConstraintTrees.SolutionTree
</code></pre><p>Convert a <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> and a vector of variable assignments (typically representing a constrained problem solution) to a <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a> of constraint values w.r.t. the given variable assignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/ada13150387da48cf51c8d4fa2f0bbec032190b9/src/solution.jl#L60">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metabolic-modeling/">« Example: Metabolic modeling</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 13 September 2023 19:18">Wednesday 13 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
