<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ConstraintTrees.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://cobrexa.github.io/ConstraintTrees.jl/stable/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConstraintTrees.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../metabolic-modeling/">Example: Metabolic modeling</a></li><li><a class="tocitem" href="../quadratic-optimization/">Example: Quadratic optimization</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Values"><span>Values</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Constraint-trees"><span>Constraint trees</span></a></li><li><a class="tocitem" href="#Solution-trees"><span>Solution trees</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Values"><a class="docs-heading-anchor" href="#Values">Values</a><a id="Values-1"></a><a class="docs-heading-anchor-permalink" href="#Values" title="Permalink"></a></h2><h3 id="Linear-and-affine-values"><a class="docs-heading-anchor" href="#Linear-and-affine-values">Linear and affine values</a><a id="Linear-and-affine-values-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-and-affine-values" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Value" href="#ConstraintTrees.Value"><code>ConstraintTrees.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Value</code></pre><p>A representation of a &quot;value&quot; in a linear constrained optimization problem. The value is an affine linear combination of several variables.</p><p><code>Value</code>s can be combined additively and multiplied by real-number constants.</p><p>Multiplying two <code>Value</code>s yields a quadratic form (in a <a href="#ConstraintTrees.QValue"><code>QValue</code></a>).</p><p><strong>Fields</strong></p><ul><li><code>idxs::Vector{Int64}</code>: Indexes of the variables used by the value. The indexes must always be sorted in strictly increasing order. The affine element has index 0.</li></ul><ul><li><code>weights::Vector{Float64}</code>: Coefficients of the variables selected by <code>idxs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/value.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Value-Tuple{Real}" href="#ConstraintTrees.Value-Tuple{Real}"><code>ConstraintTrees.Value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Value(x::Real) -&gt; ConstraintTrees.Value
</code></pre><p>Construct a constant <a href="#ConstraintTrees.Value"><code>Value</code></a> with a single affine element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/value.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Value-Tuple{SparseArrays.SparseVector{Float64}}" href="#ConstraintTrees.Value-Tuple{SparseArrays.SparseVector{Float64}}"><code>ConstraintTrees.Value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Value(
    x::SparseArrays.SparseVector{Float64}
) -&gt; ConstraintTrees.Value
</code></pre><p>Shortcut for making a <a href="#ConstraintTrees.Value"><code>Value</code></a> out of a linear combination defined by the <code>SparseVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/value.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.value_product-Tuple{ConstraintTrees.Value, Any}" href="#ConstraintTrees.value_product-Tuple{ConstraintTrees.Value, Any}"><code>ConstraintTrees.value_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value_product(x::ConstraintTrees.Value, y) -&gt; Any
</code></pre><p>Shortcut for making a dot-product between a value and anything indexable by the value indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/value.jl#L82">source</a></section></article><h3 id="Quadratic-values"><a class="docs-heading-anchor" href="#Quadratic-values">Quadratic values</a><a id="Quadratic-values-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-values" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.QValue" href="#ConstraintTrees.QValue"><code>ConstraintTrees.QValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct QValue</code></pre><p>A representation of a quadratic form in the constrained optimization problem. The <code>QValue</code> is an affine quadratic combination (i.e., a polynomial of maximum degree 2) over the variables.</p><p><code>QValue</code>s can be combined additively and multiplied by real-number constants. The cleanest way to construct a <code>QValue</code> is to multiply two <a href="#ConstraintTrees.Value"><code>Value</code></a>s.</p><p><strong>Fields</strong></p><ul><li><p><code>idxs::Vector{Tuple{Int64, Int64}}</code>: Indexes of variable pairs used by the value. The indexes must always be sorted in strictly co-lexicographically increasing order, and the second index must always be greater than or equal to the first one. (Speaking in matrix terms, the indexing follows the indexes in an upper triangular matrix by columns.)</p><p>As an outcome, the second index of the last index pair can be used as the upper bound of all variable indexes.</p><p>As with <a href="#ConstraintTrees.Value"><code>Value</code></a>, index <code>0</code> represents the affine element.</p></li></ul><ul><li><code>weights::Vector{Float64}</code>: Coefficient of the variable pairs selected by <code>idxs</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qvalue.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.QValue-Tuple{ConstraintTrees.Value}" href="#ConstraintTrees.QValue-Tuple{ConstraintTrees.Value}"><code>ConstraintTrees.QValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QValue(x::ConstraintTrees.Value) -&gt; ConstraintTrees.QValue
</code></pre><p>Construct a <a href="#ConstraintTrees.QValue"><code>QValue</code></a> that is equivalent to a given <a href="#ConstraintTrees.Value"><code>Value</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qvalue.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.QValue-Tuple{Real}" href="#ConstraintTrees.QValue-Tuple{Real}"><code>ConstraintTrees.QValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QValue(x::Real) -&gt; ConstraintTrees.QValue
</code></pre><p>Construct a constant <a href="#ConstraintTrees.QValue"><code>QValue</code></a> with a single affine element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qvalue.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.QValue-Tuple{SparseArrays.SparseMatrixCSC{Float64}}" href="#ConstraintTrees.QValue-Tuple{SparseArrays.SparseMatrixCSC{Float64}}"><code>ConstraintTrees.QValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">QValue(
    x::SparseArrays.SparseMatrixCSC{Float64}
) -&gt; ConstraintTrees.QValue
</code></pre><p>Shortcut for making a <a href="#ConstraintTrees.QValue"><code>QValue</code></a> out of a square sparse matrix. The matrix is force-symmetrized by calculating <code>x&#39; + x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qvalue.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.colex_le-Tuple{Any, Any}" href="#ConstraintTrees.colex_le-Tuple{Any, Any}"><code>ConstraintTrees.colex_le</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">colex_le(, ) -&gt; Any
</code></pre><p>Internal helper for co-lex ordering of indexes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qvalue.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.qvalue_product-Tuple{ConstraintTrees.QValue, Any}" href="#ConstraintTrees.qvalue_product-Tuple{ConstraintTrees.QValue, Any}"><code>ConstraintTrees.qvalue_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qvalue_product(x::ConstraintTrees.QValue, y) -&gt; Any
</code></pre><p>Shortcut for computing a product of the <a href="#ConstraintTrees.QValue"><code>QValue</code></a> and anything vector-like.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qvalue.jl#L128">source</a></section></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Bound" href="#ConstraintTrees.Bound"><code>ConstraintTrees.Bound</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Shortcut for possible bounds: either no bound is present (<code>nothing</code>), or a single number is interpreted as an exact equality bound, or a tuple of 2 numbers is interpreted as an interval bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/bound.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.IntervalBound" href="#ConstraintTrees.IntervalBound"><code>ConstraintTrees.IntervalBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Tuple{Float64, Float64}</code></pre><p>Convenience shortcut for &quot;interval&quot; bound; consisting of lower and upper bound value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/bound.jl#L2">source</a></section></article><h3 id="Linear-and-affine-constraints"><a class="docs-heading-anchor" href="#Linear-and-affine-constraints">Linear and affine constraints</a><a id="Linear-and-affine-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-and-affine-constraints" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Constraint" href="#ConstraintTrees.Constraint"><code>ConstraintTrees.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Constraint</code></pre><p>A representation of a single constraint that limits the <a href="#ConstraintTrees.Value"><code>Value</code></a> by a specific <a href="#ConstraintTrees.Bound"><code>Bound</code></a>.</p><p>Constraints may be scaled linearly, i.e., multiplied by real-number constants.</p><p>Constraints without a bound (<code>nothing</code> in the <code>bound</code> field) are possible; these have no impact on the optimization problem but the associated <code>value</code> becomes easily accessible for inspection and building other constraints.</p><p><strong>Fields</strong></p><ul><li><p><code>value::ConstraintTrees.Value</code>: A <a href="#ConstraintTrees.Value"><code>Value</code></a> that describes what the constraint constraints.</p></li><li><p><code>bound::Union{Nothing, Float64, Tuple{Float64, Float64}}</code>: A bound that the <code>value</code> must satisfy.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.bound-Tuple{ConstraintTrees.Constraint}" href="#ConstraintTrees.bound-Tuple{ConstraintTrees.Constraint}"><code>ConstraintTrees.bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bound(
    x::ConstraintTrees.Constraint
) -&gt; Union{Nothing, Float64, Tuple{Float64, Float64}}
</code></pre><p>Simple accessor for getting out the bound from the constraint that can be used for broadcasting (as opposed to the dot-field access).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.value-Tuple{ConstraintTrees.Constraint}" href="#ConstraintTrees.value-Tuple{ConstraintTrees.Constraint}"><code>ConstraintTrees.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(
    x::ConstraintTrees.Constraint
) -&gt; ConstraintTrees.Value
</code></pre><p>Simple accessor for getting out the value from the constraint that can be used for broadcasting (as opposed to the dot-field access).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint.jl#L40">source</a></section></article><h3 id="Quadratic-constraints"><a class="docs-heading-anchor" href="#Quadratic-constraints">Quadratic constraints</a><a id="Quadratic-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-constraints" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.Constraint" href="#ConstraintTrees.Constraint"><code>ConstraintTrees.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Constraint(
    v::ConstraintTrees.QValue
) -&gt; ConstraintTrees.QConstraint
Constraint(
    v::ConstraintTrees.QValue,
    b::Union{Nothing, Float64, Tuple{Float64, Float64}}
) -&gt; ConstraintTrees.QConstraint
</code></pre><p>Overloaded constructor of <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a> that actually makes a <a href="#ConstraintTrees.QConstraint"><code>QConstraint</code></a> because that is implied by the type of the value in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qconstraint.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.QConstraint" href="#ConstraintTrees.QConstraint"><code>ConstraintTrees.QConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct QConstraint</code></pre><p>A representation of a single quadratic constraint that limits the <a href="#ConstraintTrees.QValue"><code>QValue</code></a> by a specific <a href="#ConstraintTrees.Bound"><code>Bound</code></a>. Apart from the quadratic nature, type behaves just like the normal <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a>.</p><p><strong>Fields</strong></p><ul><li><p><code>qvalue::ConstraintTrees.QValue</code>: A <a href="#ConstraintTrees.QValue"><code>QValue</code></a> that describes what the constraint constraints.</p></li><li><p><code>bound::Union{Nothing, Float64, Tuple{Float64, Float64}}</code>: A bound that the <code>qvalue</code> must satisfy.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/qconstraint.jl#L2">source</a></section></article><h2 id="Constraint-trees"><a class="docs-heading-anchor" href="#Constraint-trees">Constraint trees</a><a id="Constraint-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.ConstraintTreeElem" href="#ConstraintTrees.ConstraintTreeElem"><code>ConstraintTrees.ConstraintTreeElem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A shortcut for elements of the <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.ConstraintTree" href="#ConstraintTrees.ConstraintTree"><code>ConstraintTrees.ConstraintTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConstraintTree</code></pre><p>A hierarchical tree of many constraints that together describe a constrained system. The tree may recursively contain other trees in a directory-like structure; and these contain <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a>s and <a href="#ConstraintTrees.QConstraint"><code>QConstraint</code></a>s.</p><p>Members of the constraint tree are accessible via the record dot syntax as properties; e.g. a constraint labeled with <code>:abc</code> in a constraint tree <code>t</code> may be accessed as <code>t.abc</code> and as <code>t[:abc]</code>, and can be found while iterating through <code>elems(t)</code>.</p><p><strong>Constructing the constraint trees</strong></p><p>Use operator <code>^</code> to put a name on a constraint to convert it into a single element <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>:</p><pre><code class="language-julia hljs">x = :my_constraint ^ Constraint(Value(...), 1.0)
dir = :my_constraint_dir ^ x

dir.my_constraint_dir.my_constraint.bound   # returns 1.0</code></pre><p>Use operator <code>*</code> to glue two constraint trees together while <em>sharing</em> the variable indexes specified by the contained <a href="#ConstraintTrees.Value"><code>Value</code></a>s and <a href="#ConstraintTrees.QValue"><code>QValue</code></a>s.</p><pre><code class="language-julia hljs">my_constraints = :linear_limit ^ Constraint(...) * :quadratic_limit ^ QConstraint(...)</code></pre><p>Use operator <code>+</code> to glue two constraint trees together <em>without sharing</em> of any variables. The operation will renumber the variables in the trees so that the sets of variable indexes used by either tree are completely disjunct, and then glue the trees together as with <code>*</code>:</p><pre><code class="language-julia hljs">two_independent_systems = my_system + other_system</code></pre><p><strong>Variable sharing limitations</strong></p><p>Because of the renumbering, you can not easily use constraints and values from the values <em>before</em> the addition in the constraint tree that is the result of the addition. There is no check against that – the resulting <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> will be valid, but will probably describe a different optimization problem than you intended.</p><p>As a rule of thumb, avoid necessary parentheses in expressions that work with the constraint trees: While <code>t1 * t2 + t3</code> might work just as intended, <code>t1 * (t2 + t3)</code> is almost certainly wrong because the variables in <code>t1</code> that are supposed to connect to variables in either of <code>t2</code> and <code>t3</code> will not connect properly because of renumbering of both <code>t2</code> and <code>t3</code>. If you need to construct a tree like that, do the addition first, and construct the <code>t1</code> after that, based on the result of the addition.</p><p><strong>Fields</strong></p><ul><li><code>elems::DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree, ConstraintTrees.QConstraint}}</code>: Sorted dictionary of elements of the constraint tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}" href="#ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}"><code>ConstraintTrees.elems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elems(
    x::ConstraintTrees.ConstraintTree
) -&gt; DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree, ConstraintTrees.QConstraint}}
</code></pre><p>Get the elements dictionary out of the <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>. This is useful for getting an iterable container for working with many constraints at once.</p><p>Also, because of the overload of <code>getproperty</code> for <code>ConstraintTree</code>, this serves as a simpler way to get the elements without an explicit use of <code>getfield</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.incr_var_idx-Tuple{Int64, Int64}" href="#ConstraintTrees.incr_var_idx-Tuple{Int64, Int64}"><code>ConstraintTrees.incr_var_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incr_var_idx(x::Int64, incr::Int64) -&gt; Int64
</code></pre><p>Internal helper for manipulating variable indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.Constraint, Int64}" href="#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.Constraint, Int64}"><code>ConstraintTrees.incr_var_idxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incr_var_idxs(
    x::ConstraintTrees.Constraint,
    incr::Int64
) -&gt; ConstraintTrees.Constraint
</code></pre><p>Offset all variable indexes in a <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a> by the given increment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.ConstraintTree, Int64}" href="#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.ConstraintTree, Int64}"><code>ConstraintTrees.incr_var_idxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incr_var_idxs(
    x::ConstraintTrees.ConstraintTree,
    incr::Int64
) -&gt; ConstraintTrees.ConstraintTree
</code></pre><p>Offset all variable indexes in a <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> by the given increment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.QConstraint, Int64}" href="#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.QConstraint, Int64}"><code>ConstraintTrees.incr_var_idxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">incr_var_idxs(
    x::ConstraintTrees.QConstraint,
    incr::Int64
) -&gt; ConstraintTrees.QConstraint
</code></pre><p>Offset all variable indexes in a <a href="#ConstraintTrees.QConstraint"><code>QConstraint</code></a> by the given increment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.var_count-Tuple{ConstraintTrees.ConstraintTree}" href="#ConstraintTrees.var_count-Tuple{ConstraintTrees.ConstraintTree}"><code>ConstraintTrees.var_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var_count(x::ConstraintTrees.ConstraintTree) -&gt; Any
</code></pre><p>Find the expected count of variables in a <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.var_count-Tuple{ConstraintTrees.Constraint}" href="#ConstraintTrees.var_count-Tuple{ConstraintTrees.Constraint}"><code>ConstraintTrees.var_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var_count(x::ConstraintTrees.Constraint) -&gt; Int64
</code></pre><p>Find the expected count of variables in a <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a>.</p><p>(This is a O(1) operation, relying on the order of indexes in <a href="#ConstraintTrees.Value"><code>Value</code></a>s.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.var_count-Tuple{ConstraintTrees.QConstraint}" href="#ConstraintTrees.var_count-Tuple{ConstraintTrees.QConstraint}"><code>ConstraintTrees.var_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var_count(x::ConstraintTrees.QConstraint) -&gt; Int64
</code></pre><p>Find the expected count of variables in a <a href="#ConstraintTrees.Constraint"><code>Constraint</code></a>.</p><p>(This is a O(1) operation, relying on the co-lexicographical ordering of indexes in <a href="#ConstraintTrees.QValue"><code>QValue</code></a>s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.variable-Tuple{}" href="#ConstraintTrees.variable-Tuple{}"><code>ConstraintTrees.variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variable(; bound) -&gt; ConstraintTrees.Constraint
</code></pre><p>Allocate a single unnamed variable, returning a Constraint with an optionally specified <code>bound</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.variables-Tuple{}" href="#ConstraintTrees.variables-Tuple{}"><code>ConstraintTrees.variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variables(; keys, bounds)
</code></pre><p>Make a trivial constraint system that creates variables with indexes in range <code>1:length(keys)</code> named in order as given by <code>keys</code>.</p><p>Parameter <code>bounds</code> is either <code>nothing</code> for creating unconstrained variables, a single bound (of precise length 1) for creating all variables of the same constraint, or an iterable object of same length as <code>keys</code> with individual bounds for each variable in the same order as <code>keys</code>.</p><p>The individual bounds should be of type <a href="#ConstraintTrees.Bound"><code>Bound</code></a>. To pass a single interval bound for all variables, it is impossible to use a tuple (since its length is 2); in such case use <code>bound = Ref((minimum, maximum))</code>, which has the correct length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/constraint_tree.jl#L256">source</a></section></article><h2 id="Solution-trees"><a class="docs-heading-anchor" href="#Solution-trees">Solution trees</a><a id="Solution-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.SolutionTreeElem" href="#ConstraintTrees.SolutionTreeElem"><code>ConstraintTrees.SolutionTreeElem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A shortcut for type of contents in a <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/solution_tree.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.SolutionTree" href="#ConstraintTrees.SolutionTree"><code>ConstraintTrees.SolutionTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SolutionTree</code></pre><p>A structure similar to <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>, but only holds the resolved values of each constraint. As with <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>, use record dot notation and <a href="#ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}"><code>elems</code></a> to browse the solution structure.</p><p>Use <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a> to construct the <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a> out of a <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> and a vector of variable values.</p><p>To construct a <code>SolutionTree</code>, combine a <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a> (or generally any <a href="#ConstraintTrees.ConstraintTreeElem"><code>ConstraintTreeElem</code></a> with a vector of variable assignments (typically representing a constrained problem solution) using the overloaded 2-parameter<a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a> constructor. The result will contain a tree of constraint values w.r.t. the given variable assignment (or just a single number in case the input was only a single constraint).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">cs = ConstraintTree(...)
vals = [1.0, 2.0, 4.0]
SolutionTree(cs, vals)</code></pre><p><strong>Fields</strong></p><ul><li><code>elems::DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/solution_tree.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConstraintTrees.elems-Tuple{ConstraintTrees.SolutionTree}" href="#ConstraintTrees.elems-Tuple{ConstraintTrees.SolutionTree}"><code>ConstraintTrees.elems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elems(
    x::ConstraintTrees.SolutionTree
) -&gt; DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}}
</code></pre><p>Get the elements dictionary out of the <a href="#ConstraintTrees.SolutionTree"><code>SolutionTree</code></a>.</p><p>The use is similar as with the overload for <a href="#ConstraintTrees.ConstraintTree"><code>ConstraintTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/2047a18f32c66170bf7079a45216390ad940f089/src/solution_tree.jl#L50">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadratic-optimization/">« Example: Quadratic optimization</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 1 October 2023 15:06">Sunday 1 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
