<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example: Metabolic modeling · ConstraintTrees.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://cobrexa.github.io/ConstraintTrees.jl/stable/metabolic-modeling/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConstraintTrees.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li class="is-active"><a class="tocitem" href>Example: Metabolic modeling</a><ul class="internal"><li><a class="tocitem" href="#Allocating-and-constraining-variables"><span>Allocating and constraining variables</span></a></li><li><a class="tocitem" href="#Adding-single-variable-constraints"><span>Adding single-variable constraints</span></a></li><li><a class="tocitem" href="#Adding-combined-constraints"><span>Adding combined constraints</span></a></li><li><a class="tocitem" href="#Saving-the-objective"><span>Saving the objective</span></a></li><li><a class="tocitem" href="#Solving-the-constraint-system-using-JuMP"><span>Solving the constraint system using JuMP</span></a></li><li><a class="tocitem" href="#Combining-and-extending-constraint-systems"><span>Combining and extending constraint systems</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example: Metabolic modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example: Metabolic modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/master/docs/src/metabolic-modeling.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example:-Metabolic-modeling"><a class="docs-heading-anchor" href="#Example:-Metabolic-modeling">Example: Metabolic modeling</a><a id="Example:-Metabolic-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Metabolic-modeling" title="Permalink"></a></h1><p>In this example we demonstrate the use of <code>ConstraintTree</code> structure for solving the metabolic modeling tasks. At the same time, we show how to export the structure to JuMP, and use <code>SolutionTree</code> to find useful information about the result.</p><p>First, let&#39;s import some packages:</p><pre><code class="language-julia hljs">import ConstraintTrees as C</code></pre><p>We will need a constraint-based metabolic model; for this test we will use the usual &quot;E. Coli core metabolism&quot; model as available from BiGG:</p><pre><code class="language-julia hljs">import Downloads: download

download(&quot;http://bigg.ucsd.edu/static/models/e_coli_core.xml&quot;, &quot;e_coli_core.xml&quot;)

import SBML
ecoli = SBML.readSBML(&quot;e_coli_core.xml&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SBML.Model with 95 reactions, 72 species, and 5 parameters.</code></pre><h2 id="Allocating-and-constraining-variables"><a class="docs-heading-anchor" href="#Allocating-and-constraining-variables">Allocating and constraining variables</a><a id="Allocating-and-constraining-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Allocating-and-constraining-variables" title="Permalink"></a></h2><p>Let&#39;s first build the constrained representation of the problem. First, we will need a variable for each of the reactions in the model.</p><pre><code class="language-julia hljs">c = C.allocate_variables(keys = Symbol.(keys(ecoli.reactions)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), nothing)…))</code></pre><p>The above operation returns a <code>ConstraintTree</code>. You can browse these as a dictionary:</p><pre><code class="language-julia hljs">C.elems(c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering} with 95 entries:
  :R_ACALD                    =&gt; Constraint(Value([73], [1.0]), nothing)
  :R_ACALDt                   =&gt; Constraint(Value([41], [1.0]), nothing)
  :R_ACKr                     =&gt; Constraint(Value([25], [1.0]), nothing)
  :R_ACONTa                   =&gt; Constraint(Value([86], [1.0]), nothing)
  :R_ACONTb                   =&gt; Constraint(Value([2], [1.0]), nothing)
  :R_ACt2r                    =&gt; Constraint(Value([81], [1.0]), nothing)
  :R_ADK1                     =&gt; Constraint(Value([51], [1.0]), nothing)
  :R_AKGDH                    =&gt; Constraint(Value([38], [1.0]), nothing)
  :R_AKGt2r                   =&gt; Constraint(Value([80], [1.0]), nothing)
  :R_ALCD2x                   =&gt; Constraint(Value([94], [1.0]), nothing)
  :R_ATPM                     =&gt; Constraint(Value([32], [1.0]), nothing)
  :R_ATPS4r                   =&gt; Constraint(Value([56], [1.0]), nothing)
  :R_BIOMASS_Ecoli_core_w_GAM =&gt; Constraint(Value([82], [1.0]), nothing)
  :R_CO2t                     =&gt; Constraint(Value([85], [1.0]), nothing)
  :R_CS                       =&gt; Constraint(Value([23], [1.0]), nothing)
  :R_CYTBD                    =&gt; Constraint(Value([64], [1.0]), nothing)
  :R_D_LACt2                  =&gt; Constraint(Value([29], [1.0]), nothing)
  :R_ENO                      =&gt; Constraint(Value([37], [1.0]), nothing)
  :R_ETOHt2r                  =&gt; Constraint(Value([24], [1.0]), nothing)
  ⋮                           =&gt; ⋮</code></pre><p>...or much more conveniently using the record dot syntax as properties:</p><pre><code class="language-julia hljs">c.R_PFK</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Constraint(ConstraintTrees.Value([49], [1.0]), nothing)</code></pre><p>The individual <code>Value</code>s in constraint behave like sparse vectors that refer to variables: The first field represents the referenced variable indexes, and the second field represents the coefficients. Compared to the sparse vectors, information about the total number of variables is not stored explicitly.</p><p>Operator <code>^</code> is used to name individual constraints and directories in the hierarchy. Let us name our constraints as &quot;fluxes&quot; (which is a common name in metabolic modeling) and explore the result:</p><pre><code class="language-julia hljs">c = :fluxes^c;</code></pre><p>We can see that there is now only a single &quot;top-level directory&quot; in the constraint system:</p><pre><code class="language-julia hljs">collect(keys(C.elems(c)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Symbol}:
 :fluxes</code></pre><p>...which can be explored with the dot access again:</p><pre><code class="language-julia hljs">c.fluxes.R_PFK</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Constraint(ConstraintTrees.Value([49], [1.0]), nothing)</code></pre><p>Indexing via values is possible via the usual bracket notation, and can be freely combined with the dot notation:</p><pre><code class="language-julia hljs">c[:fluxes][:R_PFK]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Constraint(ConstraintTrees.Value([49], [1.0]), nothing)</code></pre><h2 id="Adding-single-variable-constraints"><a class="docs-heading-anchor" href="#Adding-single-variable-constraints">Adding single-variable constraints</a><a id="Adding-single-variable-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-single-variable-constraints" title="Permalink"></a></h2><p>Each element in the constraint tree consists of a linear combination of the variables, which can be freely used to construct (and constraint) new linear combinations of variables. As the simplest use, we can constraint the variables to their valid bounds as defined by the model:</p><pre><code class="language-julia hljs">rxn_constraints =
    let rxn_bounds = Symbol.(keys(ecoli.reactions)) .=&gt; zip(SBML.flux_bounds(ecoli)...)
        C.make_constraint_tree(
            r =&gt; C.Constraint(value = c.fluxes[r].value, bound = (lb, ub)) for
            (r, ((lb, _), (ub, _))) in rxn_bounds # SBML units are ignored for simplicity
        )
    end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), (-1000.0, 1000.0))…))</code></pre><p>To combine the constraint trees, we can make a nice directory for the constraints and add them to the tree using operator <code>*</code>. Making &quot;products&quot; of constraint trees combines the trees in a way that they <em>share</em> their variables. In particular, using the values from <code>c.fluxes</code> in the constraints within <code>rxn_constraints</code> here will constraint precisely the same variables (and thus values) as the ones in the original system.</p><pre><code class="language-julia hljs">c = c * :constraints^rxn_constraints;</code></pre><p>Our model representation now contains 2 &quot;directories&quot;:</p><pre><code class="language-julia hljs">collect(keys(c))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Symbol}:
 :constraints
 :fluxes</code></pre><h2 id="Adding-combined-constraints"><a class="docs-heading-anchor" href="#Adding-combined-constraints">Adding combined constraints</a><a id="Adding-combined-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-combined-constraints" title="Permalink"></a></h2><p>Values may be combined additively and multiplied by real constants; which allows us to easily create more complex linear combination of any values already occurring in the model:</p><pre><code class="language-julia hljs">c.fluxes.R_PFK.value - 2 * c.fluxes.R_ACALD.value</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Value([49, 73], [1.0, -2.0])</code></pre><p>Metabolic modeling relies on the fact that the total rates of any metabolite getting created and consumed by the reaction equals to zero (which corresponds to conservation of mass). We can now add corresponding &quot;stoichiometric&quot; network constraints by following the reactants and products in the SBML structure:</p><pre><code class="language-julia hljs">stoi_constraints = C.make_constraint_tree(
    Symbol(m) =&gt; C.Constraint(
        value = -sum(
            (
                sr.stoichiometry * c.fluxes[Symbol(rid)].value for
                (rid, r) in ecoli.reactions for sr in r.reactants if sr.species == m
            ),
            init = zero(C.Value), # sometimes the sums are empty
        ) + sum(
            (
                sr.stoichiometry * c.fluxes[Symbol(rid)].value for
                (rid, r) in ecoli.reactions for sr in r.products if sr.species == m
            ),
            init = zero(C.Value),
        ),
        bound = 0.0,
    ) for m in keys(ecoli.species)
);</code></pre><p>Again, we can label the stoichiometry properly and add it to the bigger model representation:</p><pre><code class="language-julia hljs">c = c * :stoichiometry^stoi_constraints;</code></pre><h2 id="Saving-the-objective"><a class="docs-heading-anchor" href="#Saving-the-objective">Saving the objective</a><a id="Saving-the-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-the-objective" title="Permalink"></a></h2><p>Constraint based models typically optimize a certain linear formula. Constraint trees do not support setting objectives (they are not constraints), but we can save the objective as a harmless unconstrained &quot;constraint&quot; that can be used later to refer to the objective more easily. We can save that information into the constraint system immediately:</p><pre><code class="language-julia hljs">c *=
    :objective^C.Constraint(
        value = sum(
            c.fluxes[Symbol(rid)].value * coeff for
            (rid, coeff) in (keys(ecoli.reactions) .=&gt; SBML.flux_objective(ecoli)) if
            coeff != 0.0
        ),
    );</code></pre><h2 id="Solving-the-constraint-system-using-JuMP"><a class="docs-heading-anchor" href="#Solving-the-constraint-system-using-JuMP">Solving the constraint system using JuMP</a><a id="Solving-the-constraint-system-using-JuMP-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-constraint-system-using-JuMP" title="Permalink"></a></h2><p>We can make a small function that throws our model into JuMP, optimizes it, and gives us back a variable assignment vector. This vector can then be used to determine and browse the values of constraints and variables using <code>SolutionTree</code>.</p><pre><code class="language-julia hljs">import JuMP
function optimized_vars(cs::C.ConstraintTree, objective::C.Value, optimizer)
    model = JuMP.Model(optimizer)
    JuMP.@variable(model, x[1:C.var_count(cs)])
    JuMP.@objective(model, JuMP.MAX_SENSE, C.value_product(objective, x))
    function add_constraint(c::C.Constraint)
        if c.bound isa Float64
            JuMP.@constraint(model, C.value_product(c.value, x) == c.bound)
        elseif c.bound isa Tuple{Float64,Float64}
            val = C.value_product(c.value, x)
            isinf(c.bound[1]) || JuMP.@constraint(model, val &gt;= c.bound[1])
            isinf(c.bound[2]) || JuMP.@constraint(model, val &lt;= c.bound[2])
        end
    end
    function add_constraint(c::C.ConstraintTree)
        add_constraint.(values(c))
    end
    add_constraint(cs)
    JuMP.optimize!(model)
    JuMP.value.(model[:x])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">optimized_vars (generic function with 1 method)</code></pre><p>With this in hand, we can use an external linear problem solver to find the optimum of the constrained system:</p><pre><code class="language-julia hljs">import GLPK
optimal_variable_assignment = optimized_vars(c, c.objective.value, GLPK.Optimizer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">95-element Vector{Float64}:
   0.0
   6.00724957535031
   7.477381962160286
  -5.064375661482085
   0.22346172933182415
  -3.2148950476847733
   2.5043094703687165
  21.799492655998776
   4.959984944574683
   1.4969837572615767
   ⋮
   0.0
  29.175827135565836
   0.0
   0.0
  -6.400958585906926e-15
 -21.799492655998776
  -1.776356839400254e-15
   0.0
   3.2148950476847733</code></pre><p>To explore the solution more easily, we can make a solution tree with values that correspond to ones in our constraint tree:</p><pre><code class="language-julia hljs">result = C.solution_tree(c, optimal_variable_assignment);
result.fluxes.R_BIOMASS_Ecoli_core_w_GAM</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.8739215069684383</code></pre><pre><code class="language-julia hljs">result.fluxes.R_PFK</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.477381962160286</code></pre><pre><code class="language-julia hljs">result.objective</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.8739215069684383</code></pre><p>Sometimes it is unnecessary to recover the values for all constraints, so we are better off selecting just a subtree:</p><pre><code class="language-julia hljs">C.elems(C.solution_tree(c.fluxes, optimal_variable_assignment))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}, Base.Order.ForwardOrdering} with 95 entries:
  :R_ACALD                    =&gt; -1.98196e-15
  :R_ACALDt                   =&gt; -1.98196e-15
  :R_ACKr                     =&gt; -2.38143e-14
  :R_ACONTa                   =&gt; 6.00725
  :R_ACONTb                   =&gt; 6.00725
  :R_ACt2r                    =&gt; -2.38143e-14
  :R_ADK1                     =&gt; 8.88178e-16
  :R_AKGDH                    =&gt; 5.06438
  :R_AKGt2r                   =&gt; 0.0
  :R_ALCD2x                   =&gt; 0.0
  :R_ATPM                     =&gt; 8.39
  :R_ATPS4r                   =&gt; 45.514
  :R_BIOMASS_Ecoli_core_w_GAM =&gt; 0.873922
  :R_CO2t                     =&gt; -22.8098
  :R_CS                       =&gt; 6.00725
  :R_CYTBD                    =&gt; 43.599
  :R_D_LACt2                  =&gt; 1.95151e-14
  :R_ENO                      =&gt; 14.7161
  :R_ETOHt2r                  =&gt; 0.0
  ⋮                           =&gt; ⋮</code></pre><pre><code class="language-julia hljs">C.solution_tree(c.objective, optimal_variable_assignment)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.8739215069684383</code></pre><h2 id="Combining-and-extending-constraint-systems"><a class="docs-heading-anchor" href="#Combining-and-extending-constraint-systems">Combining and extending constraint systems</a><a id="Combining-and-extending-constraint-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-and-extending-constraint-systems" title="Permalink"></a></h2><p>Constraint trees can be extended with new variables from another constraint trees using the <code>+</code> operator. Contrary to the <code>*</code> operator, adding the constraint trees does <em>not</em> share the variables between operands, and the resulting constraint tree will basically contain two disconnected trees that solve independently. The user is expected to create additional constraints to connect the independent parts.</p><p>Here, we demonstrate this by creating a community of two slightly different E. Coli species: First, we disable functionality of a different reaction in each of the models to create a diverse group of differently handicapped organisms:</p><pre><code class="language-julia hljs">c =
    :community^(
        :species1^(c * :handicap^C.Constraint(value = c.fluxes.R_PFK.value, bound = 0.0)) +
        :species2^(c * :handicap^C.Constraint(value = c.fluxes.R_ACALD.value, bound = 0.0))
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:community =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:species1 =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), (-1000.0, 1000.0))…)), :fluxes =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), nothing)…)), :handicap =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([49], [1.0]), 0.0), :objective =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([82], [1.0]), nothing), :stoichiometry =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:M_13dpg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([21, 26], [1.0, 1.0]), 0.0), :M_2pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([37, 70], [-1.0, -1.0]), 0.0), :M_3pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([26, 70, 82], [-1.0, 1.0, -1.496]), 0.0), :M_6pgc_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([13, 59], [1.0, -1.0]), 0.0), :M_6pgl_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([9, 13], [1.0, -1.0]), 0.0), :M_ac_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25, 81], [-1.0, 1.0]), 0.0), :M_ac_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([50, 81], [-1.0, -1.0]), 0.0), :M_acald_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41, 73, 94], [1.0, -1.0, 1.0]), 0.0), :M_acald_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41, 66], [-1.0, -1.0]), 0.0), :M_accoa_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([23, 35, 48, 63, 69, 73, 82], [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -3.7478]), 0.0)…)))), :species2 =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([181], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([97], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([176], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([146], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([133], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([175], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([189], [1.0]), (-1000.0, 1000.0))…)), :fluxes =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([181], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([97], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([176], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([146], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([133], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([175], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([189], [1.0]), nothing)…)), :handicap =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), 0.0), :objective =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([177], [1.0]), nothing), :stoichiometry =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:M_13dpg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([116, 121], [1.0, 1.0]), 0.0), :M_2pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([132, 165], [-1.0, -1.0]), 0.0), :M_3pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([121, 165, 177], [-1.0, 1.0, -1.496]), 0.0), :M_6pgc_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([108, 154], [1.0, -1.0]), 0.0), :M_6pgl_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([104, 108], [1.0, -1.0]), 0.0), :M_ac_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120, 176], [-1.0, 1.0]), 0.0), :M_ac_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([145, 176], [-1.0, -1.0]), 0.0), :M_acald_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136, 168, 189], [1.0, -1.0, 1.0]), 0.0), :M_acald_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136, 161], [-1.0, -1.0]), 0.0), :M_accoa_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([118, 130, 143, 158, 164, 168, 177], [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -3.7478]), 0.0)…))))))))</code></pre><p>We can create additional variables that represent total community intake of oxygen, and total community production of biomass:</p><pre><code class="language-julia hljs">c +=
    :exchanges^C.allocate_variables(
        keys = [:oxygen, :biomass],
        bounds = [(-10.0, 10.0), nothing],
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:community =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:species1 =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), (-1000.0, 1000.0))…)), :fluxes =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), nothing)…)), :handicap =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([49], [1.0]), 0.0), :objective =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([82], [1.0]), nothing), :stoichiometry =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:M_13dpg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([21, 26], [1.0, 1.0]), 0.0), :M_2pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([37, 70], [-1.0, -1.0]), 0.0), :M_3pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([26, 70, 82], [-1.0, 1.0, -1.496]), 0.0), :M_6pgc_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([13, 59], [1.0, -1.0]), 0.0), :M_6pgl_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([9, 13], [1.0, -1.0]), 0.0), :M_ac_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25, 81], [-1.0, 1.0]), 0.0), :M_ac_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([50, 81], [-1.0, -1.0]), 0.0), :M_acald_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41, 73, 94], [1.0, -1.0, 1.0]), 0.0), :M_acald_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41, 66], [-1.0, -1.0]), 0.0), :M_accoa_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([23, 35, 48, 63, 69, 73, 82], [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -3.7478]), 0.0)…)))), :species2 =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([181], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([97], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([176], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([146], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([133], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([175], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([189], [1.0]), (-1000.0, 1000.0))…)), :fluxes =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([181], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([97], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([176], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([146], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([133], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([175], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([189], [1.0]), nothing)…)), :handicap =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), 0.0), :objective =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([177], [1.0]), nothing), :stoichiometry =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:M_13dpg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([116, 121], [1.0, 1.0]), 0.0), :M_2pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([132, 165], [-1.0, -1.0]), 0.0), :M_3pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([121, 165, 177], [-1.0, 1.0, -1.496]), 0.0), :M_6pgc_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([108, 154], [1.0, -1.0]), 0.0), :M_6pgl_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([104, 108], [1.0, -1.0]), 0.0), :M_ac_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120, 176], [-1.0, 1.0]), 0.0), :M_ac_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([145, 176], [-1.0, -1.0]), 0.0), :M_acald_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136, 168, 189], [1.0, -1.0, 1.0]), 0.0), :M_acald_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136, 161], [-1.0, -1.0]), 0.0), :M_accoa_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([118, 130, 143, 158, 164, 168, 177], [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -3.7478]), 0.0)…)))))), :exchanges =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:biomass =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([192], [1.0]), nothing), :oxygen =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([191], [1.0]), (-10.0, 10.0))))))</code></pre><p>These can be constrained so that the total influx (or outflux) of each of the registered metabolites is in fact equal to total consumption or production by each of the species:</p><pre><code class="language-julia hljs">c *=
    :exchange_constraints^C.make_constraint_tree(
        :oxygen =&gt; C.Constraint(
            value = c.exchanges.oxygen.value - c.community.species1.fluxes.R_EX_o2_e.value -
                    c.community.species2.fluxes.R_EX_o2_e.value,
            bound = 0.0,
        ),
        :biomass =&gt; C.Constraint(
            value = c.exchanges.biomass.value -
                    c.community.species1.fluxes.R_BIOMASS_Ecoli_core_w_GAM.value -
                    c.community.species2.fluxes.R_BIOMASS_Ecoli_core_w_GAM.value,
            bound = 0.0,
        ),
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:community =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:species1 =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), (-1000.0, 1000.0))…)), :fluxes =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([73], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([86], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([2], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([81], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([51], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([38], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([80], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([94], [1.0]), nothing)…)), :handicap =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([49], [1.0]), 0.0), :objective =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([82], [1.0]), nothing), :stoichiometry =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:M_13dpg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([21, 26], [1.0, 1.0]), 0.0), :M_2pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([37, 70], [-1.0, -1.0]), 0.0), :M_3pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([26, 70, 82], [-1.0, 1.0, -1.496]), 0.0), :M_6pgc_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([13, 59], [1.0, -1.0]), 0.0), :M_6pgl_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([9, 13], [1.0, -1.0]), 0.0), :M_ac_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([25, 81], [-1.0, 1.0]), 0.0), :M_ac_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([50, 81], [-1.0, -1.0]), 0.0), :M_acald_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41, 73, 94], [1.0, -1.0, 1.0]), 0.0), :M_acald_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([41, 66], [-1.0, -1.0]), 0.0), :M_accoa_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([23, 35, 48, 63, 69, 73, 82], [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -3.7478]), 0.0)…)))), :species2 =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), (-1000.0, 1000.0)), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136], [1.0]), (-1000.0, 1000.0)), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120], [1.0]), (-1000.0, 1000.0)), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([181], [1.0]), (-1000.0, 1000.0)), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([97], [1.0]), (-1000.0, 1000.0)), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([176], [1.0]), (-1000.0, 1000.0)), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([146], [1.0]), (-1000.0, 1000.0)), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([133], [1.0]), (0.0, 1000.0)), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([175], [1.0]), (-1000.0, 1000.0)), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([189], [1.0]), (-1000.0, 1000.0))…)), :fluxes =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:R_ACALD =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), nothing), :R_ACALDt =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136], [1.0]), nothing), :R_ACKr =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120], [1.0]), nothing), :R_ACONTa =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([181], [1.0]), nothing), :R_ACONTb =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([97], [1.0]), nothing), :R_ACt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([176], [1.0]), nothing), :R_ADK1 =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([146], [1.0]), nothing), :R_AKGDH =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([133], [1.0]), nothing), :R_AKGt2r =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([175], [1.0]), nothing), :R_ALCD2x =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([189], [1.0]), nothing)…)), :handicap =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([168], [1.0]), 0.0), :objective =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([177], [1.0]), nothing), :stoichiometry =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:M_13dpg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([116, 121], [1.0, 1.0]), 0.0), :M_2pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([132, 165], [-1.0, -1.0]), 0.0), :M_3pg_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([121, 165, 177], [-1.0, 1.0, -1.496]), 0.0), :M_6pgc_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([108, 154], [1.0, -1.0]), 0.0), :M_6pgl_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([104, 108], [1.0, -1.0]), 0.0), :M_ac_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([120, 176], [-1.0, 1.0]), 0.0), :M_ac_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([145, 176], [-1.0, -1.0]), 0.0), :M_acald_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136, 168, 189], [1.0, -1.0, 1.0]), 0.0), :M_acald_e =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([136, 161], [-1.0, -1.0]), 0.0), :M_accoa_c =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([118, 130, 143, 158, 164, 168, 177], [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -3.7478]), 0.0)…)))))), :exchange_constraints =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:biomass =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([82, 177, 192], [-1.0, -1.0, 1.0]), 0.0), :oxygen =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([92, 187, 191], [-1.0, -1.0, 1.0]), 0.0))), :exchanges =&gt; ConstraintTrees.ConstraintTree(DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}, Base.Order.ForwardOrdering}(:biomass =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([192], [1.0]), nothing), :oxygen =&gt; ConstraintTrees.Constraint(ConstraintTrees.Value([191], [1.0]), (-10.0, 10.0))))))</code></pre><p>Let&#39;s see how much biomass are the two species capable of producing together:</p><pre><code class="language-julia hljs">result = C.solution_tree(c, optimized_vars(c, c.exchanges.biomass.value, GLPK.Optimizer));
C.elems(result.exchanges)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}, Base.Order.ForwardOrdering} with 2 entries:
  :biomass =&gt; 0.469658
  :oxygen  =&gt; -10.0</code></pre><p>Finally, we can iterate over all species in the small community and see how much biomass was actually contributed by each:</p><pre><code class="language-julia hljs">[k =&gt; v.fluxes.R_BIOMASS_Ecoli_core_w_GAM for (k, v) in result.community]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Pair{Symbol, Float64}}:
 :species1 =&gt; 0.027425032310385615
 :species2 =&gt; 0.4422324728108645</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« README</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 September 2023 06:55">Thursday 14 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
