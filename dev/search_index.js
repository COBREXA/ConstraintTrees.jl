var documenterSearchIndex = {"docs":
[{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"EditURL = \"3-mixed-integer-optimization.jl\"","category":"page"},{"location":"3-mixed-integer-optimization/#Example:-Mixed-integer-optimization-(MILP)","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"","category":"section"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"This example demonstrates the extension of ConstraintTree bounds structures to accomodate new kinds of problems. In particular, we create a new kind of Bound that is restricting the value to be a full integer, and then solve a geometric problem with that.","category":"page"},{"location":"3-mixed-integer-optimization/#Creating-a-custom-bound","page":"Example: Mixed integer optimization (MILP)","title":"Creating a custom bound","text":"","category":"section"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"All bounds contained in constraints are subtypes of the abstract ConstraintTrees.Bound. These include ConstraintTrees.EqualTo and ConstraintTrees.Between, but the types can be extended as necessary, given the final rewriting of the constraint system to JuMP can handle the new bounds.","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"Let's make a small \"marker\" bound for something that needs to be integer-ish, between 2 integers:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"import ConstraintTrees as C\n\nmutable struct IntegerFromTo <: C.Bound\n    from::Int\n    to::Int\nend","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"We can now write e.g. a bound on the number on a thrown six-sided die as follows:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"IntegerFromTo(1, 6)","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"...and include this bound in constraints and variables:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"dice_system =\n    C.variables(keys = [:first_dice, :second_dice], bounds = [IntegerFromTo(1, 6)])","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"Now the main thing that is left is to be able to translate this bound to JuMP for solving. We can slightly generalize our constraint-translation system from the previous examples for this purpose, by separating out the functions that create the constraints:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"import JuMP\n\nfunction jump_constraint(m, x, v::C.Value, b::C.EqualTo)\n    JuMP.@constraint(m, C.substitute(v, x) == b.equal_to)\nend\n\nfunction jump_constraint(m, x, v::C.Value, b::C.Between)\n    isinf(b.lower) || JuMP.@constraint(m, C.substitute(v, x) >= b.lower)\n    isinf(b.upper) || JuMP.@constraint(m, C.substitute(v, x) <= b.upper)\nend","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"JuMP does not support direct integrality constraints, so we need to make a small disgression with a slack variable:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"function jump_constraint(m, x, v::C.Value, b::IntegerFromTo)\n    var = JuMP.@variable(m, integer = true)\n    JuMP.@constraint(m, var >= b.from)\n    JuMP.@constraint(m, var <= b.to)\n    JuMP.@constraint(m, C.substitute(v, x) == var)\nend\n\nfunction milp_optimized_vars(cs::C.ConstraintTree, objective::C.Value, optimizer)\n    model = JuMP.Model(optimizer)\n    JuMP.@variable(model, x[1:C.var_count(cs)])\n    JuMP.@objective(model, JuMP.MAX_SENSE, C.substitute(objective, x))\n    function add_constraint(c::C.Constraint)\n        isnothing(c.bound) || jump_constraint(model, x, c.value, c.bound)\n    end\n    function add_constraint(c::C.ConstraintTree)\n        add_constraint.(values(c))\n    end\n    add_constraint(cs)\n    JuMP.set_silent(model)\n    JuMP.optimize!(model)\n    JuMP.value.(model[:x])\nend","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"Let's try to solve a tiny system with the dice first. What's the best value we can throw if the dice are thrown at least 1.5 points apart?","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"dice_system *=\n    :points_distance^C.Constraint(\n        dice_system.first_dice.value - dice_system.second_dice.value,\n        C.Between(1.5, Inf),\n    )","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"For solving, we use GLPK (it has MILP capabilities).","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"import GLPK\ndices_thrown = C.constraint_values(\n    dice_system,\n    milp_optimized_vars(\n        dice_system,\n        dice_system.first_dice.value + dice_system.second_dice.value,\n        GLPK.Optimizer,\n    ),\n)","category":"page"},{"location":"3-mixed-integer-optimization/#A-more-realistic-example-with-geometry","page":"Example: Mixed integer optimization (MILP)","title":"A more realistic example with geometry","text":"","category":"section"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"Let's find the size of the smallest right-angled triangle with integer side sizes (aka a Pythagorean triple).","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"vars = C.variables(keys = [:a, :b, :c], bounds = (IntegerFromTo(1, 100),))","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"For simpliclty, we make a shortcut for \"values\" in all variables:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"v = C.tree_map(vars, C.value, C.Value)","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"With that shortcut, the constraint tree constructs quite easily:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"triangle_system =\n    :sides^vars *\n    :circumference^C.Constraint(sum(values(v))) *\n    :a_less_than_b^C.Constraint(v.b - v.a, (0, Inf)) *\n    :b_less_than_c^C.Constraint(v.c - v.b, (0, Inf)) *\n    :right_angled^C.Constraint(C.squared(v.a) + C.squared(v.b) - C.squared(v.c), 0.0)","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"We will need a solver that supports both quadratic and integer optimization:","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"import SCIP\ntriangle_sides =\n    C.constraint_values(\n        triangle_system,\n        milp_optimized_vars(\n            triangle_system,\n            -triangle_system.circumference.value,\n            SCIP.Optimizer,\n        ),\n    ).sides","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"","category":"page"},{"location":"3-mixed-integer-optimization/","page":"Example: Mixed integer optimization (MILP)","title":"Example: Mixed integer optimization (MILP)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"EditURL = \"2-quadratic-optimization.jl\"","category":"page"},{"location":"2-quadratic-optimization/#Example:-Quadratic-optimization","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"","category":"section"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"In this example we demonstrate the use of quadratic constraints and values. We assume that the reader is already familiar with the construction of ConstraintTrees; if not, it is advisable to read the previous part of the documentation first.","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"In short, quadratic values and constraints are expressed similarly as other contents of the constraint trees using type QuadraticValue, which is basically an affine-quadratic alike of the affine-linear LinearValue.","category":"page"},{"location":"2-quadratic-optimization/#Working-with-quadratic-values-and-constraints","page":"Example: Quadratic optimization","title":"Working with quadratic values and constraints","text":"","category":"section"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"Algebraically, you can construct QuadraticValues simply by multiplying the linear LinearValues:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"import ConstraintTrees as C\n\nsystem = C.variables(keys = [:x, :y, :z])\nqv = system.x.value * (system.y.value + 2 * system.z.value)","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"As with LinearValues, the QuadraticValues can be easily combined, giving a nice way to specify e.g. weighted sums of squared errors with respect to various directions. We can thus represent common formulas for error values:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"error_val =\n    C.squared(system.x.value + system.y.value - 1) +\n    C.squared(system.y.value + 5 * system.z.value - 3)","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"This allows us to naturally express quadratic constraint (e.g., that an error must not be too big); and directly observe the error values in the system.","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"system = :vars^system * :error^C.Constraint(error_val, C.Between(0, 100))","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"(For simplicity, you can also use the Constraint constructor to make quadratic constraints out of QuadraticValues – it will overload properly.)","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"Let's pretend someone has solved the system, and see how much \"error\" the solution has:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"solution = [1.0, 2.0, -1.0]\nst = C.constraint_values(system, solution)\nst.error","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"...not bad for a first guess.","category":"page"},{"location":"2-quadratic-optimization/#Building-quadratic-systems","page":"Example: Quadratic optimization","title":"Building quadratic systems","text":"","category":"section"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"Let's create a small quadratic system that finds the closest distance between an ellipse and a line and let some of the conic solvers available in JuMP solve it. First, let's make a representation of a point in 2D:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"point = C.variables(keys = [:x, :y])","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"We can create a small system that constraints the point to stay within a simple elliptical area centered around (0.0, 10.0):","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"ellipse_system = C.ConstraintTree(\n    :point => point,\n    :in_area => C.Constraint(\n        C.squared(point.x.value) / 4 + C.squared(10.0 - point.y.value),\n        C.Between(-Inf, 1.0),\n    ),\n)","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"We now create another small system that constraints another point to stay on a line that crosses (0, 0) and (2, 1). We could do this using a dot-product representation of line, but that would lead to issues later (mainly, the solver that we are planning to use only supports positive definite quadratic forms as constraints). Instead, let's use a single-variable-parametrized line equation.","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"line_param = C.variable().value\nline_system =\n    :point^C.ConstraintTree(\n        :x => C.Constraint(0 + 2 * line_param),\n        :y => C.Constraint(0 + 1 * line_param),\n    )","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"Finally, let's connect the systems using + operator and add the objective that would minimize the distance of the points:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"s = :ellipse^ellipse_system + :line^line_system\n\ns *=\n    :objective^C.Constraint(\n        C.squared(s.ellipse.point.x.value - s.line.point.x.value) +\n        C.squared(s.ellipse.point.y.value - s.line.point.y.value),\n    )","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"(Note that if we used * to connect the systems, the variables from the definition of point would not be duplicated, and various non-interesting logic errors would follow.)","category":"page"},{"location":"2-quadratic-optimization/#Solving-quadratic-systems-with-JuMP","page":"Example: Quadratic optimization","title":"Solving quadratic systems with JuMP","text":"","category":"section"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"To solve the above system, we need a matching solver that can work with quadratic constraints. Also, we need to slightly generalize the function that translates the constraints into JuMP Models to support the quadratic constraints.","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"import JuMP\nfunction quad_optimized_vars(cs::C.ConstraintTree, objective::C.Value, optimizer)\n    model = JuMP.Model(optimizer)\n    JuMP.@variable(model, x[1:C.var_count(cs)])\n    JuMP.@objective(model, JuMP.MAX_SENSE, C.substitute(objective, x))\n    function add_constraint(c::C.Constraint)\n        b = c.bound\n        if b isa C.EqualTo\n            JuMP.@constraint(model, C.substitute(c.value, x) == b.equal_to)\n        elseif b isa C.Between\n            val = C.substitute(c.value, x)\n            isinf(b.lower) || JuMP.@constraint(model, val >= b.lower)\n            isinf(b.upper) || JuMP.@constraint(model, val <= b.upper)\n        end\n    end\n    function add_constraint(c::C.ConstraintTree)\n        add_constraint.(values(c))\n    end\n    add_constraint(cs)\n    JuMP.set_silent(model)\n    JuMP.optimize!(model)\n    JuMP.value.(model[:x])\nend","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"We can now load a suitable optimizer and solve the system by maximizing the negative squared error:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"import Clarabel\nst = C.constraint_values(s, quad_optimized_vars(s, -s.objective.value, Clarabel.Optimizer))","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"If the optimization worked well, we can nicely get out the position of the closest point to the line that is in the elliptical area:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"(st.ellipse.point.x, st.ellipse.point.y)","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"...as well as the position on the line that is closest to the ellipse:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"st.line.point","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"...and, with a little bit of extra math, the minimized distance:","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"sqrt(st.objective)","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"","category":"page"},{"location":"2-quadratic-optimization/","page":"Example: Quadratic optimization","title":"Example: Quadratic optimization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Values","page":"Reference","title":"Values","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/value.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.Value","page":"Reference","title":"ConstraintTrees.Value","text":"abstract type Value\n\nAbstract type of all values usable in constraints, including LinearValue and QuadraticValue.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Linear-and-affine-values","page":"Reference","title":"Linear and affine values","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/linear_value.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.LinearValue","page":"Reference","title":"ConstraintTrees.LinearValue","text":"struct LinearValue <: ConstraintTrees.Value\n\nA representation of a \"value\" in a linear constrained optimization problem. The value is an affine linear combination of several variables.\n\nLinearValues can be combined additively and multiplied by real-number constants.\n\nMultiplying two LinearValues yields a quadratic form (in a QuadraticValue).\n\nFields\n\nidxs::Vector{Int64}: Indexes of the variables used by the value. The indexes must always be sorted in strictly increasing order. The affine element has index 0.\n\nweights::Vector{Float64}: Coefficients of the variables selected by idxs.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.LinearValue-Tuple{Real}","page":"Reference","title":"ConstraintTrees.LinearValue","text":"LinearValue(x::Real) -> ConstraintTrees.LinearValue\n\n\nConstruct a constant LinearValue with a single affine element.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.LinearValue-Tuple{SparseArrays.SparseVector{Float64}}","page":"Reference","title":"ConstraintTrees.LinearValue","text":"LinearValue(\n    x::SparseArrays.SparseVector{Float64}\n) -> ConstraintTrees.LinearValue\n\n\nShortcut for making a LinearValue out of a linear combination defined by the SparseVector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.substitute-Tuple{ConstraintTrees.LinearValue, Any}","page":"Reference","title":"ConstraintTrees.substitute","text":"substitute(x::ConstraintTrees.LinearValue, y) -> Any\n\n\nSubstitute anything vector-like as variable values into a LinearValue and return the result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quadratic-values","page":"Reference","title":"Quadratic values","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/quadratic_value.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.QuadraticValue","page":"Reference","title":"ConstraintTrees.QuadraticValue","text":"struct QuadraticValue <: ConstraintTrees.Value\n\nA representation of a quadratic form in the constrained optimization problem. The QuadraticValue is an affine quadratic combination (i.e., a polynomial of maximum degree 2) over the variables.\n\nQuadraticValues can be combined additively and multiplied by real-number constants. The cleanest way to construct a QuadraticValue is to multiply two LinearValues.\n\nFields\n\nidxs::Vector{Tuple{Int64, Int64}}: Indexes of variable pairs used by the value. The indexes must always be sorted in strictly co-lexicographically increasing order, and the second index must always be greater than or equal to the first one. (Speaking in matrix terms, the indexing follows the indexes in an upper triangular matrix by columns.)\nAs an outcome, the second index of the last index pair can be used as the upper bound of all variable indexes.\nAs with LinearValue, index 0 represents the affine element.\n\nweights::Vector{Float64}: Coefficient of the variable pairs selected by idxs.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.QuadraticValue-Tuple{ConstraintTrees.LinearValue}","page":"Reference","title":"ConstraintTrees.QuadraticValue","text":"QuadraticValue(\n    x::ConstraintTrees.LinearValue\n) -> ConstraintTrees.QuadraticValue\n\n\nConstruct a QuadraticValue that is equivalent to a given LinearValue.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.QuadraticValue-Tuple{Real}","page":"Reference","title":"ConstraintTrees.QuadraticValue","text":"QuadraticValue(x::Real) -> ConstraintTrees.QuadraticValue\n\n\nConstruct a constant QuadraticValue with a single affine element.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.QuadraticValue-Tuple{SparseArrays.SparseMatrixCSC{Float64}}","page":"Reference","title":"ConstraintTrees.QuadraticValue","text":"QuadraticValue(\n    x::SparseArrays.SparseMatrixCSC{Float64}\n) -> ConstraintTrees.QuadraticValue\n\n\nShortcut for making a QuadraticValue out of a square sparse matrix. The matrix is force-symmetrized by calculating x' + x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.colex_le-Tuple{Any, Any}","page":"Reference","title":"ConstraintTrees.colex_le","text":"colex_le(, ) -> Any\n\n\nInternal helper for co-lex ordering of indexes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.squared-Tuple{ConstraintTrees.LinearValue}","page":"Reference","title":"ConstraintTrees.squared","text":"squared(\n    a::ConstraintTrees.LinearValue\n) -> ConstraintTrees.QuadraticValue\n\n\nBroadcastable shortcut for multiplying a LinearValue with itself. Produces a QuadraticValue.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.substitute-Tuple{ConstraintTrees.QuadraticValue, Any}","page":"Reference","title":"ConstraintTrees.substitute","text":"substitute(x::ConstraintTrees.QuadraticValue, y) -> Any\n\n\nSubstitute anything vector-like as variable values into the QuadraticValue and return the result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Constraints","page":"Reference","title":"Constraints","text":"","category":"section"},{"location":"reference/#Bounds","page":"Reference","title":"Bounds","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/bound.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.MaybeBound","page":"Reference","title":"ConstraintTrees.MaybeBound","text":"Shortcut for all possible Bounds including the \"empty\" bound that does not constraint anything (represented by nothing).\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.Between","page":"Reference","title":"ConstraintTrees.Between","text":"mutable struct Between <: ConstraintTrees.Bound\n\nRepresentation of an \"interval\" bound; consisting of lower and upper bound value.\n\nFields\n\nlower::Float64: Lower bound\nupper::Float64: Upper bound\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.Bound","page":"Reference","title":"ConstraintTrees.Bound","text":"abstract type Bound\n\nAbstract type of all bounds usable in constraints, including Between and EqualTo.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.EqualTo","page":"Reference","title":"ConstraintTrees.EqualTo","text":"mutable struct EqualTo <: ConstraintTrees.Bound\n\nRepresentation of an \"equality\" bound; contains the single \"equal to this\" value.\n\nFields\n\nequal_to::Float64: Equality bound value\n\n\n\n\n\n","category":"type"},{"location":"reference/#Constrained-values","page":"Reference","title":"Constrained values","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/constraint.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.Constraint","page":"Reference","title":"ConstraintTrees.Constraint","text":"mutable struct Constraint{V, B}\n\nA representation of a single constraint that may limit the given value by a specific Bound.\n\nConstraints without a bound (nothing in the bound field) are possible; these have no impact on the optimization problem but the associated value becomes easily accessible for inspection and building other constraints.\n\nFields\n\nvalue::Any: A value (typically a LinearValue or a QuadraticValue)     that describes what the constraint constraints.\nbound::Any: A bound that the value must satisfy. Should be a subtype of     MaybeBound: Either nothing if there's no bound, or e.g.     EqualTo, Between or similar structs.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.bound-Tuple{ConstraintTrees.Constraint}","page":"Reference","title":"ConstraintTrees.bound","text":"bound(x::ConstraintTrees.Constraint) -> Any\n\n\nSimple accessor for getting out the bound from the constraint that can be used for broadcasting (as opposed to the dot-field access).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.substitute-Tuple{ConstraintTrees.Constraint, Any}","page":"Reference","title":"ConstraintTrees.substitute","text":"substitute(\n    x::ConstraintTrees.Constraint,\n    y\n) -> ConstraintTrees.Constraint\n\n\nSubstitute anything vector-like as variables into the constraint's value, producing a constraint with the new value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.value-Tuple{ConstraintTrees.Constraint}","page":"Reference","title":"ConstraintTrees.value","text":"value(x::ConstraintTrees.Constraint) -> Any\n\n\nSimple accessor for getting out the value from the constraint that can be used for broadcasting (as opposed to the dot-field access).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Labeled-trees","page":"Reference","title":"Labeled trees","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/tree.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.Tree","page":"Reference","title":"ConstraintTrees.Tree","text":"struct Tree{X}\n\nA base \"labeled tree\" structure. Supports many interesting operations such as merging.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.elems-Tuple{ConstraintTrees.Tree}","page":"Reference","title":"ConstraintTrees.elems","text":"elems(\n    x::ConstraintTrees.Tree\n) -> DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Tree{X}, X}} where X\n\n\nGet the elements dictionary out of the Tree. This is useful for getting an iterable container for working with many items at once.\n\nAlso, because of the overload of getproperty for Tree, this serves as a simpler way to get the elements without an explicit use of getfield.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.tree_map-Tuple{ConstraintTrees.Tree, Any, DataType}","page":"Reference","title":"ConstraintTrees.tree_map","text":"tree_map(\n    x::ConstraintTrees.Tree,\n    f,\n    output_type::DataType\n) -> ConstraintTrees.Tree\n\n\nRun a function over everything in the tree. The resulting tree will contain elements of type output_type. (This needs to be specified explicitly, because the typesystem generally cannot guess the type correctly.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Constraint-trees","page":"Reference","title":"Constraint trees","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/constraint_tree.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.ConstraintTreeElem","page":"Reference","title":"ConstraintTrees.ConstraintTreeElem","text":"A shortcut for the type of the values in ConstraintTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.ConstraintTree","page":"Reference","title":"ConstraintTrees.ConstraintTree","text":"struct Tree{ConstraintTrees.Constraint}\n\nA hierarchical tree of many constraints that together describe a constrained system. The tree may recursively contain other trees in a directory-like structure, which contain Constraints as leaves.\n\nMembers of the constraint tree are accessible via the record dot syntax as properties; e.g. a constraint labeled with :abc in a constraint tree t may be accessed as t.abc and as t[:abc], and can be found while iterating through elems(t).\n\nConstructing the constraint trees\n\nUse operator ^ to put a name on a constraint to convert it into a single element ConstraintTree:\n\nx = :my_constraint ^ Constraint(LinearValue(...), 1.0)\ndir = :my_constraint_dir ^ x\n\ndir.my_constraint_dir.my_constraint.bound   # returns 1.0\n\nUse operator * to glue two constraint trees together while sharing the variable indexes specified by the contained LinearValues and QuadraticValues.\n\nmy_constraints = :some_constraints ^ Constraint(...) * :more_constraints ^ Constraint(...)\n\nUse operator + to glue two constraint trees together without sharing of any variables. The operation will renumber the variables in the trees so that the sets of variable indexes used by either tree are completely disjunct, and then glue the trees together as with *:\n\ntwo_independent_systems = my_system + other_system\n\nVariable sharing limitations\n\nBecause of the renumbering, you can not easily use constraints and values from the values before the addition in the constraint tree that is the result of the addition. There is no check against that – the resulting ConstraintTree will be valid, but will probably describe a different optimization problem than you intended.\n\nAs a rule of thumb, avoid necessary parentheses in expressions that work with the constraint trees: While t1 * t2 + t3 might work just as intended, t1 * (t2 + t3) is almost certainly wrong because the variables in t1 that are supposed to connect to variables in either of t2 and t3 will not connect properly because of renumbering of both t2 and t3. If you need to construct a tree like that, do the addition first, and construct the t1 after that, based on the result of the addition.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.constraint_values-Tuple{ConstraintTrees.Constraint, Vector{Float64}}","page":"Reference","title":"ConstraintTrees.constraint_values","text":"constraint_values(\n    x::ConstraintTrees.Constraint,\n    y::Vector{Float64}\n) -> Float64\n\n\nFallback for constraint_values for a single constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.constraint_values-Tuple{ConstraintTrees.Tree{ConstraintTrees.Constraint}, Vector{Float64}}","page":"Reference","title":"ConstraintTrees.constraint_values","text":"constraint_values(\n    x::ConstraintTrees.Tree{ConstraintTrees.Constraint},\n    y::Vector{Float64}\n) -> ConstraintTrees.Tree{Float64}\n\n\nSubstitute variable values from y into the constraint tree's constraint's values, getting a tree of \"solved\" constraint values for the given variable assignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.incr_var_idx-Tuple{Int64, Int64}","page":"Reference","title":"ConstraintTrees.incr_var_idx","text":"incr_var_idx(x::Int64, incr::Int64) -> Int64\n\n\nInternal helper for manipulating variable indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.Constraint, Int64}","page":"Reference","title":"ConstraintTrees.incr_var_idxs","text":"incr_var_idxs(\n    x::ConstraintTrees.Constraint,\n    incr::Int64\n) -> ConstraintTrees.Constraint\n\n\nOffset all variable indexes in a ConstraintTree by the given increment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.LinearValue, Int64}","page":"Reference","title":"ConstraintTrees.incr_var_idxs","text":"incr_var_idxs(\n    x::ConstraintTrees.LinearValue,\n    incr::Int64\n) -> ConstraintTrees.LinearValue\n\n\nOffset all variable indexes in a LinearValue by the given increment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.QuadraticValue, Int64}","page":"Reference","title":"ConstraintTrees.incr_var_idxs","text":"incr_var_idxs(\n    x::ConstraintTrees.QuadraticValue,\n    incr::Int64\n) -> ConstraintTrees.QuadraticValue\n\n\nOffset all variable indexes in a QuadraticValue by the given increment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.incr_var_idxs-Tuple{ConstraintTrees.Tree{ConstraintTrees.Constraint}, Int64}","page":"Reference","title":"ConstraintTrees.incr_var_idxs","text":"incr_var_idxs(\n    x::ConstraintTrees.Tree{ConstraintTrees.Constraint},\n    incr::Int64\n) -> ConstraintTrees.Tree{ConstraintTrees.Constraint}\n\n\nOffset all variable indexes in a ConstraintTree by the given increment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.var_count-Tuple{ConstraintTrees.Constraint}","page":"Reference","title":"ConstraintTrees.var_count","text":"var_count(x::ConstraintTrees.Constraint) -> Any\n\n\nFind the expected count of variables in a Constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.var_count-Tuple{ConstraintTrees.LinearValue}","page":"Reference","title":"ConstraintTrees.var_count","text":"var_count(x::ConstraintTrees.LinearValue) -> Int64\n\n\nFind the expected count of variables in a LinearValue. (This is a O(1) operation, relying on the ordering of the indexes.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.var_count-Tuple{ConstraintTrees.QuadraticValue}","page":"Reference","title":"ConstraintTrees.var_count","text":"var_count(x::ConstraintTrees.QuadraticValue) -> Int64\n\n\nFind the expected count of variables in a QuadraticValue. (This is a O(1) operation, relying on the co-lexicographical ordering of indexes.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.var_count-Tuple{ConstraintTrees.Tree{ConstraintTrees.Constraint}}","page":"Reference","title":"ConstraintTrees.var_count","text":"var_count(\n    x::ConstraintTrees.Tree{ConstraintTrees.Constraint}\n) -> Any\n\n\nFind the expected count of variables in a ConstraintTree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.variable-Tuple{}","page":"Reference","title":"ConstraintTrees.variable","text":"variable(\n;\n    bound\n) -> ConstraintTrees.Constraint{ConstraintTrees.LinearValue, Nothing}\n\n\nAllocate a single unnamed variable, returning a Constraint with an optionally specified bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.variables-Tuple{}","page":"Reference","title":"ConstraintTrees.variables","text":"variables(; keys, bounds)\n\n\nMake a trivial constraint system that creates variables with indexes in range 1:length(keys) named in order as given by keys.\n\nParameter bounds is either nothing for creating unconstrained variables, a single bound (of precise length 1) for creating all variables of the same constraint, or an iterable object of same length as keys with individual bounds for each variable in the same order as keys.\n\nThe individual bounds should be subtypes of Bound, or nothing. To pass a single interval bound for all variables, it is impossible to use a tuple (since its length is measured as 2); in such case use bound = Ref((minimum, maximum)), which has the correct length.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Trees-for-storing-solved-values","page":"Reference","title":"Trees for storing solved values","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"src/value_tree.jl\"]","category":"page"},{"location":"#ConstraintTrees.jl","page":"README","title":"ConstraintTrees.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Modules = [ConstraintTrees]\nPages = [\"src/ConstraintTrees.jl\"]","category":"page"},{"location":"#ConstraintTrees.ConstraintTrees","page":"README","title":"ConstraintTrees.ConstraintTrees","text":"Package ConstraintTrees.jl provides a simple data structure ConstraintTree for organizing the contents of linear and quadratic constrained optimization problems. As a main goal, it abstracts over the distinction between constraints and variables, allowing much tidier representation for many kinds of complex constraint systems.\n\nThe primary purpose of ConstraintTrees.jl is to work with COBREXA.jl; but the package is otherwise completely independent, lightweight, dependency-free and usecase-agnostic. Generally, it is intended to be used with JuMP and the documentation uses JuMP for demonstrations, but any other solver framework will do just as well.\n\nThe package is structured as follows:\n\nThere is no representation for variables in the model; instead, values depend on anonymous numbered variables, and, if suitable, special named values may \"implicitly\" serve as representations for variables. This assumption erases the distinction between a \"simple\" variable and a complex derived linear combination, allowing more freedom in model construction.\nVariables may be combined into LinearValues and QuadraticValues, which are affine combinations and quadratic-affine combinations (respecitively) of values of some selected variables.\nValues may be bounded to an interval or exact value using a Constraint\nA collection of named Constraints is called a ConstraintTree; it behaves mostly as a specialized Symbol-keyed dictionary.\nConstraintTrees can be very easily organized into subdirectories, combined and made independent on each other using operators ^, *, and + – this forms the basis of the \"tidy\" algebra of constraints.\nA variable assignment, which is typically the \"solution\" for a given constraint tree, can be combined with a ConstraintTree to create a \"value tree\" via constraint_values, which enables browsing of the optimization results in the very same structure as the input ConstraintTree.\n\nYou can follow the examples in documentation and the docstrings of package contents for more details.\n\n\n\n\n\n","category":"module"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"EditURL = \"1-metabolic-modeling.jl\"","category":"page"},{"location":"1-metabolic-modeling/#Example:-Metabolic-modeling","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"In this example we demonstrate the use of ConstraintTree structure for solving the metabolic modeling tasks. At the same time, we show how to export the structure to JuMP, and use value trees to find useful information about the result.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"First, let's import some packages:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"import ConstraintTrees as C","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We will need a constraint-based metabolic model; for this test we will use the usual \"E. Coli core metabolism\" model as available from BiGG:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"import Downloads: download\n\ndownload(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nimport SBML\necoli = SBML.readSBML(\"e_coli_core.xml\")","category":"page"},{"location":"1-metabolic-modeling/#Allocating-and-constraining-variables","page":"Example: Metabolic modeling","title":"Allocating and constraining variables","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Let's first build the constrained representation of the problem. First, we will need a variable for each of the reactions in the model.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c = C.variables(keys = Symbol.(keys(ecoli.reactions)))","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"info: Pretty-printing\nBy default, Julia shows relatively long namespace prefixes before all identifiers, which clutters the output. You can import individual names form ConstraintTrees package to improve the pretty-printing, using e.g.: import ConstraintTrees: Constraint, Tree, LinearValue.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"The above operation returns a ConstraintTree. You can browse these as a dictionary:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c[:R_PFK]","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"...or much more conveniently using the record dot syntax as properties:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c.R_PFK","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"The individual LinearValues in constraints behave like sparse vectors that refer to variables: The first field represents the referenced variable indexes, and the second field represents the coefficients. Compared to the sparse vectors, information about the total number of variables is not stored explicitly.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Operator ^ is used to name individual constraints and directories in the hierarchy. Let us name our constraints as \"fluxes\" (which is a common name in metabolic modeling) and explore the result:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c = :fluxes^c","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We can see that there is now only a single \"top-level directory\" in the constraint system, which can be explored with the dot access again:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c.fluxes.R_PFK","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Indexing via values is again possible via the usual bracket notation, and can be freely combined with the dot notation:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c[:fluxes][:R_PFK]","category":"page"},{"location":"1-metabolic-modeling/#Adding-single-variable-constraints","page":"Example: Metabolic modeling","title":"Adding single-variable constraints","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Each element in the constraint tree consists of a linear combination of the variables, which can be freely used to construct (and constraint) new linear combinations of variables. As the simplest use, we can constraint the variables to their valid bounds as defined by the model:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"rxn_constraints =\n    let rxn_bounds = Symbol.(keys(ecoli.reactions)) .=> zip(SBML.flux_bounds(ecoli)...)\n        C.ConstraintTree(\n            r => C.Constraint(value = c.fluxes[r].value, bound = (lb, ub)) for\n            (r, ((lb, _), (ub, _))) in rxn_bounds # SBML units are ignored for simplicity\n        )\n    end","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Note that in the example we use a simplified Dict-like construction of the ConstraintTree. You might equivalently write the code as a product (using prod()) of constraints that are individually labeled using the ^ operator, but the direct dictionary construction is faster because it skips many intermediate steps, and looks much more like idiomatic Julia code.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To combine the constraint trees, we can make a nice directory for the constraints and add them to the tree using operator *. Making \"products\" of constraint trees combines the trees in a way that they share their variables. In particular, using the values from c.fluxes in the constraints within rxn_constraints here will constraint precisely the same variables (and thus values) as the ones in the original system.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c = c * :constraints^rxn_constraints","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Our model representation now contains 2 \"directories\":","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"collect(keys(c))","category":"page"},{"location":"1-metabolic-modeling/#Value-and-constraint-arithmetics","page":"Example: Metabolic modeling","title":"Value and constraint arithmetics","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Values may be combined additively and multiplied by real constants; which allows us to easily create more complex linear combination of any values already occurring in the model:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"3 * c.fluxes.R_PFK.value - c.fluxes.R_ACALD.value / 2","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"For simplicity, you can also scale whole constraints, but it is impossible to add them together because the meaning of the bounds would get broken:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"(3 * c.fluxes.R_PFK, -c.fluxes.R_ACALD / 2)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To process constraints in bulk, you may use C.value for easier access to values when making new constraints:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"sum(C.value.(values(c.fluxes)))","category":"page"},{"location":"1-metabolic-modeling/#Affine-values","page":"Example: Metabolic modeling","title":"Affine values","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To simplify various modeling goals (mainly calculation of various kinds of \"distances\"), the values support inclusion of an affine element – the variable with index 0 is assumed to be the \"affine unit\", and its assigned value is fixed at 1.0.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To demonstrate, let's make a small system with 2 variables.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"system = C.variables(keys = [:x, :y])","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To add an affine element to a LinearValue, simply add it as a Real number, as in the linear transformations below:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"system =\n    :original_coords^system *\n    :transformed_coords^C.ConstraintTree(\n        :xt => C.Constraint(1 + system.x.value + 4 + system.y.value),\n        :yt => C.Constraint(0.1 * (3 - system.y.value)),\n    )","category":"page"},{"location":"1-metabolic-modeling/#Adding-combined-constraints","page":"Example: Metabolic modeling","title":"Adding combined constraints","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Metabolic modeling relies on the fact that the total rates of any metabolite getting created and consumed by the reaction equals to zero (which corresponds to conservation of mass). We can now add corresponding \"stoichiometric\" network constraints by following the reactants and products in the SBML structure:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"stoi_constraints = C.ConstraintTree(\n    Symbol(m) => C.Constraint(\n        value = -sum(\n            (\n                sr.stoichiometry * c.fluxes[Symbol(rid)].value for\n                (rid, r) in ecoli.reactions for sr in r.reactants if sr.species == m\n            ),\n            init = zero(C.LinearValue), # sometimes the sums are empty\n        ) + sum(\n            (\n                sr.stoichiometry * c.fluxes[Symbol(rid)].value for\n                (rid, r) in ecoli.reactions for sr in r.products if sr.species == m\n            ),\n            init = zero(C.LinearValue),\n        ),\n        bound = 0.0,\n    ) for m in keys(ecoli.species)\n);\nnothing #hide","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Let's have a closer look at one of the constraints:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"stoi_constraints.M_acald_c","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Again, we can label the stoichiometry properly and add it to the bigger model representation:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c = c * :stoichiometry^stoi_constraints","category":"page"},{"location":"1-metabolic-modeling/#Saving-the-objective","page":"Example: Metabolic modeling","title":"Saving the objective","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Constraint based models typically optimize a certain linear formula. Constraint trees do not support setting objectives (they are not constraints), but we can save the objective as a harmless unconstrained \"constraint\" that can be used later to refer to the objective more easily. We can save that information into the constraint system immediately:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c *=\n    :objective^C.Constraint(\n        sum(\n            c.fluxes[Symbol(rid)].value * coeff for\n            (rid, coeff) in (keys(ecoli.reactions) .=> SBML.flux_objective(ecoli)) if\n            coeff != 0.0\n        ),\n    )","category":"page"},{"location":"1-metabolic-modeling/#Constrained-system-solutions-and-value-trees","page":"Example: Metabolic modeling","title":"Constrained system solutions and value trees","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To aid exploration of variable assignments in the constraint trees, we can convert them to value trees. These have the very same structure as constraint trees, but carry only the \"solved\" constraint values instead of full constraints.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Let's demonstrate this quickly on the example of system with affine variables from above. First, let's assume that someone solved the system (in some way) and produced a solution of variables as follows:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"solution = [1.0, 5.0] # corresponds to :x and :y in order given in `variables`","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"A value tree for this solution is constructed in a straightforward manner:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"st = C.constraint_values(system, solution)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We can now check the values of the original coordinates","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"st.original_coords","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"The other constraints automatically get their values that correspond to the overall variable assignment:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"st.transformed_coords","category":"page"},{"location":"1-metabolic-modeling/#Solving-the-constraint-system-using-JuMP","page":"Example: Metabolic modeling","title":"Solving the constraint system using JuMP","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We can make a small function that throws our model into JuMP, optimizes it, and gives us back a variable assignment vector. This vector can then be used to determine and browse the values of constraints and variables using a Float64-valued tree.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"import JuMP\nfunction optimized_vars(cs::C.ConstraintTree, objective::C.LinearValue, optimizer)\n    model = JuMP.Model(optimizer)\n    JuMP.@variable(model, x[1:C.var_count(cs)])\n    JuMP.@objective(model, JuMP.MAX_SENSE, C.substitute(objective, x))\n    function add_constraint(c::C.Constraint)\n        b = c.bound\n        if b isa C.EqualTo\n            JuMP.@constraint(model, C.substitute(c.value, x) == b.equal_to)\n        elseif b isa C.Between\n            val = C.substitute(c.value, x)\n            isinf(b.lower) || JuMP.@constraint(model, val >= b.lower)\n            isinf(b.upper) || JuMP.@constraint(model, val <= b.upper)\n        end\n    end\n    function add_constraint(c::C.ConstraintTree)\n        add_constraint.(values(c))\n    end\n    add_constraint(cs)\n    JuMP.optimize!(model)\n    JuMP.value.(model[:x])\nend","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"With this in hand, we can use an external linear problem solver to find the optimum of the constrained system:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"import GLPK\noptimal_variable_assignment = optimized_vars(c, c.objective.value, GLPK.Optimizer)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"To explore the solution more easily, we can make a tree with values that correspond to ones in our constraint tree:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"result = C.constraint_values(c, optimal_variable_assignment)\n\nresult.fluxes.R_BIOMASS_Ecoli_core_w_GAM","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"result.fluxes.R_PFK","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Sometimes it is unnecessary to recover the values for all constraints, so we are better off selecting just the right subtree:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"C.constraint_values(c.fluxes, optimal_variable_assignment)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"C.constraint_values(c.objective, optimal_variable_assignment)","category":"page"},{"location":"1-metabolic-modeling/#Combining-and-extending-constraint-systems","page":"Example: Metabolic modeling","title":"Combining and extending constraint systems","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Constraint trees can be extended with new variables from another constraint trees using the + operator. Contrary to the * operator, adding the constraint trees does not share the variables between operands, and the resulting constraint tree will basically contain two disconnected trees that solve independently. The user is expected to create additional constraints to connect the independent parts.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Here, we demonstrate this by creating a community of two slightly different E. Coli species: First, we disable functionality of a different reaction in each of the models to create a diverse group of differently handicapped organisms:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c =\n    :community^(\n        :species1^(c * :handicap^C.Constraint(c.fluxes.R_PFK.value, 0)) +\n        :species2^(c * :handicap^C.Constraint(c.fluxes.R_ACALD.value, 0))\n    )","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We can create additional variables that represent total community intake of oxygen, and total community production of biomass:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c += :exchanges^C.variables(keys = [:oxygen, :biomass], bounds = [(-10.0, 10.0), nothing])","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"These can be constrained so that the total influx (or outflux) of each of the registered metabolites is in fact equal to total consumption or production by each of the species:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c *=\n    :exchange_constraints^C.ConstraintTree(\n        :oxygen => C.Constraint(\n            value = c.exchanges.oxygen.value - c.community.species1.fluxes.R_EX_o2_e.value -\n                    c.community.species2.fluxes.R_EX_o2_e.value,\n            bound = 0.0,\n        ),\n        :biomass => C.Constraint(\n            value = c.exchanges.biomass.value -\n                    c.community.species1.fluxes.R_BIOMASS_Ecoli_core_w_GAM.value -\n                    c.community.species2.fluxes.R_BIOMASS_Ecoli_core_w_GAM.value,\n            bound = 0.0,\n        ),\n    )","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Let's see how much biomass are the two species capable of producing together:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"result =\n    C.constraint_values(c, optimized_vars(c, c.exchanges.biomass.value, GLPK.Optimizer))\nresult.exchanges","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Finally, we can iterate over all species in the small community and see how much biomass was actually contributed by each:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Dict(k => v.fluxes.R_BIOMASS_Ecoli_core_w_GAM for (k, v) in result.community)","category":"page"},{"location":"1-metabolic-modeling/#Modifying-constraint-systems-in-place","page":"Example: Metabolic modeling","title":"Modifying constraint systems in-place","text":"","category":"section"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Constraint trees can be modified in-place in a way that allows you to easily change small values in the trees without reconstructing them from the ground up.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Although in-place modification is extremely convenient and looks much easier than rebuilding the tree, it may be very detrimental to the robustness and efficiency of the programs, for several reasons:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"changing any data breaks assumptions on anything that was already derived from the data\nfor efficiency, the tree structures are not copied by default if there's no need to do it, and only shared by references; which means that a naive change at a single place of the tree may easily change values also in other parts of any trees, including completely different trees\nthe \"convenient way\" of making sure that the above problem never happens is to deep-copy the whole tree structure, which is typically quite detrimental to memory use and program efficiency","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"danger: Rules of thumb for safe use of in-place modification\nOnly use the in-place modifications if:there is code that explicitly makes sure there is no false sharing via references, e.g. using a deep copy\nthe in-place modifications are the last thing happening to the constraint tree before it is used by the solver\nthe in-place modification code is not a part of a re-usable library","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Now, if you are completely sure that ignoring the robustness guidelines will help your code, you can do the in-place tree modifications quite easily using both dot-access and array-index syntax.","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"You can thus, e.g., set a single bound:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c.exchanges.oxygen.bound = C.Between(-20.0, 20.0)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"...or rebuild a whole constraint (using a tuple shortcut for ConstraintTrees.Between):","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c.exchanges.biomass = C.Constraint(c.exchanges.biomass.value, (-20, 20))","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"...or even add new constraints, here using the index syntax for demonstration:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c[:exchanges][:production_is_zero] = C.Constraint(c.exchanges.biomass.value, 0)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"...or remove some constraints (this erases the constraint that was added just above):","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"delete!(c.exchanges, :production_is_zero)","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"In the end, the flux optimization yields an expectably different result:","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"result =\n    C.constraint_values(c, optimized_vars(c, c.exchanges.biomass.value, GLPK.Optimizer))\nresult.exchanges","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"","category":"page"},{"location":"1-metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"This page was generated using Literate.jl.","category":"page"}]
}
