var documenterSearchIndex = {"docs":
[{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"EditURL = \"metabolic-modeling.jl\"","category":"page"},{"location":"metabolic-modeling/#Example:-Metabolic-modeling","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"","category":"section"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"In this example we demonstrate the use of ConstraintTree structure for solving the metabolic modeling tasks. At the same time, we show how to export the structure to JuMP, and use SolutionTree to find useful information about the result.","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"First, let's import some packages:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"import ConstraintTrees as C\nimport JuMP, SBML","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We will need a constraint-based metabolic model; for this test we will use the usual \"E. Coli core metabolism\" model as available from BiGG:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"import Downloads: download\n\ndownload(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\necoli = SBML.readSBML(\"e_coli_core.xml\")","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Let's first build the constrained representation of the problem. First, we will need a variable for each of the reactions in the model:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c = C.allocate_variables(keys = Symbol.(keys(ecoli.reactions)));\nnothing #hide","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"The above operation returns a ConstraintTree. You can browse these as a dictionary:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"C.elems(c)","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"...or much more conveniently using the record dot syntax as properties:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c.R_PFK","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"Operator ^ is used to name individual constraints and directories in the hierarchy. Let us name our constraints as \"fluxes\" (which is a common name in metabolic modeling) and explore the result:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c = :fluxes^c;\nnothing #hide","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"We can see that there is now only a single \"top-level directory\" in the constraint system:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"collect(keys(C.elems(c)))","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"...which can be explored with the dot access again:","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"c.fluxes.R_PFK","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"","category":"page"},{"location":"metabolic-modeling/","page":"Example: Metabolic modeling","title":"Example: Metabolic modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Values-(linear-combinations-of-variables)","page":"Reference","title":"Values (linear combinations of variables)","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"value.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.Value","page":"Reference","title":"ConstraintTrees.Value","text":"struct Value\n\nA representation of a \"value\" in a linear constrained optimization problem. The value is a linear combination of several variables.\n\nValues can be combined additively and multiplied by real-number constants.\n\nFields\n\nidxs::Vector{Int64}: Indexes of the variables used by the value. The indexes are always sorted in increasing order.\n\nweights::Vector{Float64}: Coefficients of the variables as used by the value\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.Value-Tuple{SparseArrays.SparseVector{Float64}}","page":"Reference","title":"ConstraintTrees.Value","text":"Value(\n    x::SparseArrays.SparseVector{Float64}\n) -> ConstraintTrees.Value\n\n\nShortcut for making a Value out of SparseVector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.value_product-Tuple{ConstraintTrees.Value, Any}","page":"Reference","title":"ConstraintTrees.value_product","text":"value_product(x::ConstraintTrees.Value, y) -> Any\n\n\nShortcut for making a dot-product between a value and anything indexable by the value indexes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Constraints","page":"Reference","title":"Constraints","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"constraint.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.Bound","page":"Reference","title":"ConstraintTrees.Bound","text":"Shortcut for possible bounds: either no bound is present (nothing), or a single number is interpreted as an exact equality bound, or a tuple of 2 values is interpreted as an interval bound.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.Constraint","page":"Reference","title":"ConstraintTrees.Constraint","text":"struct Constraint\n\nA representation of a single constraint that limits the Value by a specific Bound.\n\nConstraints may be multiplied by real-number constants.\n\nConstraints without a bound (nothing in the bound field) are possible; these have no impact on the optimization problem but the associated value becomes easily accessible for inspection and building other constraints.\n\nFields\n\nvalue::ConstraintTrees.Value: A Value that describes what the constraint constraints.\nbound::Union{Nothing, Float64, Tuple{Float64, Float64}}: A bound that the value must satisfy.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.IntervalBound","page":"Reference","title":"ConstraintTrees.IntervalBound","text":"struct Tuple{Float64, Float64}\n\nConvenience shortcut for \"interval\" bound; consisting of lower and upper bound value.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.value-Tuple{ConstraintTrees.Constraint}","page":"Reference","title":"ConstraintTrees.value","text":"value(\n    x::ConstraintTrees.Constraint\n) -> ConstraintTrees.Value\n\n\nSimple accessor for getting out the value from the constraint that can be used for broadcasting (as opposed to the dot-field access).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Constraint-trees","page":"Reference","title":"Constraint trees","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"constraint_tree.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.ConstraintTreeElem","page":"Reference","title":"ConstraintTrees.ConstraintTreeElem","text":"A shortcut for elements of the ConstraintTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.ConstraintTree","page":"Reference","title":"ConstraintTrees.ConstraintTree","text":"struct ConstraintTree\n\nA hierarchical tree of many constraints that together describe a constrained linear system. The tree may recursively contain other trees in a directory-like structure.\n\nMembers of the constraint tree are accessible via the record dot syntax as properties; e.g. a constraint labeled with :abc in a constraint tree t may be accessed as t.abc and as t[:abc], and can be found while iterating through elems(t).\n\nConstructing the constraint trees\n\nUse operator ^ to put a name on a Constraint to convert it into a single element ConstraintTree:\n\nx = :my_constraint ^ Constraint(Value(...), 1.0)\ndir = :my_constraint_dir ^ x\n\ndir.my_constraint_dir.my_constraint.bound   # returns 1.0\n\nUse operator * to glue two constraint trees together while sharing the variable indexes specified by the contained Values.\n\nmy_constraints = :constraint1 ^ Constraint(...) * :constraint2 ^ Constraint(...)\n\nUse operator + to glue two constraint trees together without sharing of any variables. The operation will renumber the variables in the trees so that the sets of variable indexes used by either tree are completely disjunct, and then glue the trees together as with *:\n\ntwo_independent_systems = my_system + other_system\n\nBecause of the renumbering, you can not easily use constraints and values from the values before the addition in the constraint tree that is the result of the addition. There is no check against that; the resulting ConstraintTree will be valid, but will probably describe a different optimization problem than you intended.\n\nAs a rule of thumb, avoid necessary parentheses in expressions that work with the constraint trees: While t1 * t2 + t3 might work just as intended, t1 * (t2 + t3) is almost certainly wrong because the variables in t1 that are supposed to connect to variables in either of t2 and t3 will not connect properly because of renumbering of both t2 and t3. If you need to construct a tree like that, do the addition first, and construct the t1 after that, based on the result of the addition.\n\nFields\n\nelems::DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}}: Sorted dictionary of elements of the constraint tree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.allocate_variables-Tuple{}","page":"Reference","title":"ConstraintTrees.allocate_variables","text":"allocate_variables(; keys, bounds)\n\n\nMake a trivial constraint system that creates variables with indexes in range 1:length(keys) named in order as given by keys.\n\nParameter bounds is either nothing for creating unconstrained variables, a single bound (of precise length 1) for creating all variables of the same constraint, or an iterable object of same length as keys with individual bounds for each variable in the same order as keys.\n\nThe individual bounds should be of type Bound. To pass a single interval bound for all variables, it is impossible to use a tuple (since its length is 2); in such case use bound = Ref((minimum, maximum)), which has the correct length.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.elems-Tuple{ConstraintTrees.ConstraintTree}","page":"Reference","title":"ConstraintTrees.elems","text":"elems(\n    x::ConstraintTrees.ConstraintTree\n) -> DataStructures.SortedDict{Symbol, Union{ConstraintTrees.Constraint, ConstraintTrees.ConstraintTree}}\n\n\nGet the elements dictionary out of the ConstraintTree. This is useful for getting an iterable container for working with many constraints at once.\n\nAlso, because of the overload of getproperty for ConstraintTree, this serves as a simpler way to get the elements without an explicit use of getfield.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.make_constraint_tree-Tuple","page":"Reference","title":"ConstraintTrees.make_constraint_tree","text":"make_constraint_tree(x...) -> ConstraintTrees.ConstraintTree\n\n\nCreate a properly typed ConstraintTree out of anything that can be used to construct the inner dictionary.\n\nExample\n\nmake_constraint_tree(:a => some_constraint, :b => another_constraint)\nmake_constraint_tree(c for c=constraints if !isnothing(c.bound))\n\n\n\n\n\n","category":"method"},{"location":"reference/#Solution-trees","page":"Reference","title":"Solution trees","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ConstraintTrees]\nPages = [\"solution.jl\"]","category":"page"},{"location":"reference/#ConstraintTrees.SolutionTreeElem","page":"Reference","title":"ConstraintTrees.SolutionTreeElem","text":"A shortcut for type of contents in a SolutionTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.SolutionTree","page":"Reference","title":"ConstraintTrees.SolutionTree","text":"struct SolutionTree\n\nA structure similar to ConstraintTree, but only holds the resolved values of each constraint. As with ConstraintTree, use record dot notation and elems to browse the solution structure.\n\nUse solution_tree to construct the SolutionTree out of a ConstraintTree and a vector of variable values.\n\nFields\n\nelems::DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#ConstraintTrees.elems-Tuple{ConstraintTrees.SolutionTree}","page":"Reference","title":"ConstraintTrees.elems","text":"elems(\n    x::ConstraintTrees.SolutionTree\n) -> DataStructures.SortedDict{Symbol, Union{Float64, ConstraintTrees.SolutionTree}}\n\n\nGet the elements dictionary out of the SolutionTree.\n\nThe use is similar as with the overload for ConstraintTree.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.solution_tree-Tuple{ConstraintTrees.Constraint, AbstractVector{Float64}}","page":"Reference","title":"ConstraintTrees.solution_tree","text":"solution_tree(\n    x::ConstraintTrees.Constraint,\n    vars::AbstractVector{Float64}\n) -> Any\n\n\nConvert a single constraint and a vector of variable assignments (typically representing a constrained problem solution) to the value of the constraint w.r.t. the given variable assignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ConstraintTrees.solution_tree-Tuple{ConstraintTrees.ConstraintTree, AbstractVector{Float64}}","page":"Reference","title":"ConstraintTrees.solution_tree","text":"solution_tree(\n    x::ConstraintTrees.ConstraintTree,\n    vars::AbstractVector{Float64}\n) -> ConstraintTrees.SolutionTree\n\n\nConvert a ConstraintTree and a vector of variable assignments (typically representing a constrained problem solution) to a SolutionTree of constraint values w.r.t. the given variable assignment.\n\n\n\n\n\n","category":"method"},{"location":"#ConstraintTrees.jl","page":"README","title":"ConstraintTrees.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Modules = [ConstraintTrees]\nPages = [\"ConstraintTrees.jl\"]","category":"page"},{"location":"#ConstraintTrees.ConstraintTrees","page":"README","title":"ConstraintTrees.ConstraintTrees","text":"ConstraintTrees.jl – Tidy constraints for linear programming\n\nBuild status Documentation\n(Image: CI status) (Image: codecov) (Image: stable documentation) (Image: dev documentation)\n\nConstraintTree provides a simple data structure ConstraintTree for organizing the contents of constraint-based linear problems. As a main goal, it abstracts over the distinction between constraints and variables, allowing much tidier representation for many kinds of complex constraint systems. The primary purpose is to support constraint-based metabolic modeling within COBREXA.jl.\n\nAcknowledgements\n\nConstraintTrees.jl was developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb) and at Institute for Quantitative and Theoretical Biology at Heinrich Heine University Düsseldorf (qtb.hhu.de). The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu), agreement no. 951773.\n\n<img src=\"docs/src/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\">   <img src=\"docs/src/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\">   <img src=\"docs/src/assets/hhu.svg\" alt=\"HHU logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"docs/src/assets/qtb.svg\" alt=\"QTB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"docs/src/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\">\n\n\n\n\n\n","category":"module"}]
}
