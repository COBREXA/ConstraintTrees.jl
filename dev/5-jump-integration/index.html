<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Better integration with JuMP · ConstraintTrees.jl</title><meta name="title" content="Better integration with JuMP · ConstraintTrees.jl"/><meta property="og:title" content="Better integration with JuMP · ConstraintTrees.jl"/><meta property="twitter:title" content="Better integration with JuMP · ConstraintTrees.jl"/><meta name="description" content="Documentation for ConstraintTrees.jl."/><meta property="og:description" content="Documentation for ConstraintTrees.jl."/><meta property="twitter:description" content="Documentation for ConstraintTrees.jl."/><meta property="og:url" content="https://cobrexa.github.io/ConstraintTrees.jl/stable/5-jump-integration/"/><meta property="twitter:url" content="https://cobrexa.github.io/ConstraintTrees.jl/stable/5-jump-integration/"/><link rel="canonical" href="https://cobrexa.github.io/ConstraintTrees.jl/stable/5-jump-integration/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConstraintTrees.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../0-quickstart/">Quick start</a></li><li><a class="tocitem" href="../1-metabolic-modeling/">Example: Metabolic modeling</a></li><li><a class="tocitem" href="../2-quadratic-optimization/">Example: Quadratic optimization</a></li><li><a class="tocitem" href="../3-mixed-integer-optimization/">Example: Mixed integer optimization (MILP)</a></li><li><a class="tocitem" href="../4-functional-tree-processing/">Example: Processing the trees functionally</a></li><li class="is-active"><a class="tocitem" href>Better integration with JuMP</a><ul class="internal"><li><a class="tocitem" href="#Substitution-folding-problem"><span>Substitution folding problem</span></a></li><li><a class="tocitem" href="#Solution:-Prevent-successive-folding"><span>Solution: Prevent successive folding</span></a></li><li><a class="tocitem" href="#Solution-for-JuMP"><span>Solution for JuMP</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Better integration with JuMP</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Better integration with JuMP</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/COBREXA/ConstraintTrees.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/COBREXA/ConstraintTrees.jl/blob/master/docs/src/5-jump-integration.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Better-integration-with-JuMP"><a class="docs-heading-anchor" href="#Better-integration-with-JuMP">Better integration with JuMP</a><a id="Better-integration-with-JuMP-1"></a><a class="docs-heading-anchor-permalink" href="#Better-integration-with-JuMP" title="Permalink"></a></h1><p>The examples in this documentation generally used the simple and straightforward method of converting the trees and values to JuMP system, which depends on algebraic operators working transparently with JuMP values within function <a href="../reference/#ConstraintTrees.substitute-Tuple{ConstraintTrees.LinearValue, Any}"><code>substitute</code></a>.</p><h2 id="Substitution-folding-problem"><a class="docs-heading-anchor" href="#Substitution-folding-problem">Substitution folding problem</a><a id="Substitution-folding-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Substitution-folding-problem" title="Permalink"></a></h2><p>Despite the simplicity, this approach is sometimes sub-optimal, especially in cases when the result of the substitution is recalculated with added values. For example, in the naive case, JuMP is forced to successively build representations for all intermediate expressions with incomplete variables, until all variables are in place. In turn, this may very easily reach a quadratic computational complexity.</p><p>More generally, any representation of substitution result that &quot;does not <code>reduce()</code> easily&quot; will suffer from this problem. A different (often specialized) approach is thus needed.</p><h2 id="Solution:-Prevent-successive-folding"><a class="docs-heading-anchor" href="#Solution:-Prevent-successive-folding">Solution: Prevent successive folding</a><a id="Solution:-Prevent-successive-folding-1"></a><a class="docs-heading-anchor-permalink" href="#Solution:-Prevent-successive-folding" title="Permalink"></a></h2><p>For such cases, it is recommended to replace the <code>substitute</code> calls with a custom function that can interpret the required <a href="../reference/#ConstraintTrees.Value"><code>Value</code></a>s itself, and converts them without the overhead of creating temporary values.</p><pre><code class="language-julia hljs">import ConstraintTrees as C</code></pre><p>First, let&#39;s create a lot of variables, and a constraint that will usually trigger this problem (and a JuMP warning) if used with normal <a href="../reference/#ConstraintTrees.substitute-Tuple{ConstraintTrees.LinearValue, Any}"><code>substitute</code></a>:</p><pre><code class="language-julia hljs">x = :vars^C.variables(keys = Symbol.(&quot;x$i&quot; for i = 1:1000), bounds = C.Between(0, 10))
x *= :sum^C.Constraint(sum(C.value.(values(x.vars))))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ConstraintTrees.Tree{ConstraintTrees.Constraint} with 2 elements:
  :sum  =&gt; ConstraintTrees.Constraint(ConstraintTrees.LinearValue(#= ... =#))
  :vars =&gt; ConstraintTrees.Tree{ConstraintTrees.Constraint}(#= 1000 elements =#)</code></pre><p>Now, imagine the expressions are represented e.g. by sparse vectors of fixed size (as common in linear-algebraic systems). We can produce the vectors efficiently as follows:</p><pre><code class="language-julia hljs">import SparseArrays: sparsevec
v = x.sum.value

value_in_a_vector = sparsevec(v.idxs, v.weights, 1000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1000-element SparseArrays.SparseVector{Float64, Int64} with 1000 stored entries:
  [1   ]  =  1.0
  [2   ]  =  1.0
  [3   ]  =  1.0
  [4   ]  =  1.0
  [5   ]  =  1.0
  [6   ]  =  1.0
  [7   ]  =  1.0
          ⋮
  [993 ]  =  1.0
  [994 ]  =  1.0
  [995 ]  =  1.0
  [996 ]  =  1.0
  [997 ]  =  1.0
  [998 ]  =  1.0
  [999 ]  =  1.0
  [1000]  =  1.0</code></pre><p>This usually requires only a single memory allocation, and runs in time linear with the number of variables in the value. As an obvious downside, you need to implement this functionality for all kinds of <a href="../reference/#ConstraintTrees.Value"><code>Value</code></a>s you encounter.</p><h2 id="Solution-for-JuMP"><a class="docs-heading-anchor" href="#Solution-for-JuMP">Solution for JuMP</a><a id="Solution-for-JuMP-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-for-JuMP" title="Permalink"></a></h2><p><a href="../reference/#ConstraintTrees.LinearValue"><code>LinearValue</code></a>s can be translated to JuMP&#39;s <code>AffExpr</code>s:</p><pre><code class="language-julia hljs">using JuMP, GLPK

function substitute_jump(val::C.LinearValue, vars)
    e = AffExpr() # unfortunately @expression(model, 0) is not type stable and gives an Int
    for (i, w) in zip(val.idxs, val.weights)
        if i == 0
            add_to_expression!(e, w)
        else
            add_to_expression!(e, w, vars[i])
        end
    end
    e
end

model = Model(GLPK.Optimizer)
@variable(model, V[1:1000])
jump_value = substitute_jump(x.sum.value, V)</code></pre><p class="math-container">\[ V_{1} + V_{2} + V_{3} + V_{4} + V_{5} + V_{6} + V_{7} + V_{8} + V_{9} + V_{10} + V_{11} + V_{12} + V_{13} + V_{14} + V_{15} + V_{16} + V_{17} + V_{18} + V_{19} + V_{20} + V_{21} + V_{22} + V_{23} + V_{24} + V_{25} + V_{26} + V_{27} + V_{28} + V_{29} + V_{30} + [[\ldots\text{940 terms omitted}\ldots]] + V_{971} + V_{972} + V_{973} + V_{974} + V_{975} + V_{976} + V_{977} + V_{978} + V_{979} + V_{980} + V_{981} + V_{982} + V_{983} + V_{984} + V_{985} + V_{986} + V_{987} + V_{988} + V_{989} + V_{990} + V_{991} + V_{992} + V_{993} + V_{994} + V_{995} + V_{996} + V_{997} + V_{998} + V_{999} + V_{1000} \]</p><p>This function can be re-used in functions like <code>optimized_vars</code> as shown in other examples in the documentation.</p><p>For <a href="../reference/#ConstraintTrees.QuadraticValue"><code>QuadraticValue</code></a>s, the same approach extends only with a minor modification:</p><pre><code class="language-julia hljs">function substitute_jump(val::C.QuadraticValue, vars)
    e = QuadExpr() # unfortunately @expression(model, 0) is not type stable and gives an Int
    for ((i, j), w) in zip(val.idxs, val.weights)
        if i == 0 &amp;&amp; j == 0
            add_to_expression!(e, w)
        elseif i == 0 # the symmetric case is prohibited
            add_to_expression!(e, w, vars[j])
        else
            add_to_expression!(e, w, vars[i], vars[j])
        end
    end
    e
end

qvalue = 123 + (x.vars.x1.value + x.vars.x2.value) * (x.vars.x3.value - 321)
jump_qvalue = substitute_jump(qvalue, V)</code></pre><p class="math-container">\[ V_{1}\times V_{3} + V_{2}\times V_{3} - 321 V_{1} - 321 V_{2} + 123 \]</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../4-functional-tree-processing/">« Example: Processing the trees functionally</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 25 July 2024 14:33">Thursday 25 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
